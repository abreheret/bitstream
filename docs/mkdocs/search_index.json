{
    "docs": [
        {
            "location": "/overview/", 
            "text": "Overview\n\n\nStatement of need\n\n\nState of the art, links, etc.\n\n\nWhere to go next\n\n\n\n\nBitstream provides a binary data type with a stream interface \nfor \nPython\n.\n\n\n\n\n\n\nBinary Data:\n the \nBitStream\n class is a linearly ordered container of bits.\n    The standard library is only convenient to manage binary data at the byte level. \n    Consider using BitStream instead, especially you need to address the bit level.\n\n\n\n\n\n\nStream Interface:\n you can only read data at the start of a stream \n    and write data at its end.\n    This is a very simple way to interact with binary data, but it is also\n    the pattern that comes naturally in many applications. To manage\n    binary codes and formats, in my experience, random data access is \n    not a requirement.\n\n\n\n\n\n\nPython and Numpy Types.\n BitStream has built-in readers and writers\n    for the common data types with a standard binary layout: bools, \n    ASCII strings, fixed-size integers and floating-point integers. \n\n\n\n\n\n\nUser-Defined Types.\n The list of supported types and binary \n    representation may be enlarged at will: new readers and writers \n    can be implemented and associated to specific data types.\n\n\n\n\n\n\nPerformance.\n Bitstream is a Python C-extension module that has been\n    optimized for the common use cases. Hopefully, it will be fast enough \n    for your needs ! Under the hood, the \nCython\n language and compiler \n    are used to generate this extension module.\n\n\n\n\n\n\nOpen-Source:\n the Bitstream software is distributed under a [MIT license]\n    \nMIT\n, its documentation under a [Creative Commons Attribution 3.0] \n    \nCC-BY-3.0\n license. The development takes place on [GitHub] [] and \n    releases are also available on [PyPi] [].", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#overview", 
            "text": "Statement of need  State of the art, links, etc.  Where to go next   Bitstream provides a binary data type with a stream interface \nfor  Python .    Binary Data:  the  BitStream  class is a linearly ordered container of bits.\n    The standard library is only convenient to manage binary data at the byte level. \n    Consider using BitStream instead, especially you need to address the bit level.    Stream Interface:  you can only read data at the start of a stream \n    and write data at its end.\n    This is a very simple way to interact with binary data, but it is also\n    the pattern that comes naturally in many applications. To manage\n    binary codes and formats, in my experience, random data access is \n    not a requirement.    Python and Numpy Types.  BitStream has built-in readers and writers\n    for the common data types with a standard binary layout: bools, \n    ASCII strings, fixed-size integers and floating-point integers.     User-Defined Types.  The list of supported types and binary \n    representation may be enlarged at will: new readers and writers \n    can be implemented and associated to specific data types.    Performance.  Bitstream is a Python C-extension module that has been\n    optimized for the common use cases. Hopefully, it will be fast enough \n    for your needs ! Under the hood, the  Cython  language and compiler \n    are used to generate this extension module.    Open-Source:  the Bitstream software is distributed under a [MIT license]\n     MIT , its documentation under a [Creative Commons Attribution 3.0] \n     CC-BY-3.0  license. The development takes place on [GitHub] [] and \n    releases are also available on [PyPi] [].", 
            "title": "Overview"
        }, 
        {
            "location": "/", 
            "text": "Binary Data Stream\n\n\nOverview\n\n\nTODO\n\n\nQuickstart\n\n\n\n\nInstall wish with pip (\ninstructions\n).\n\n\n\n\n\n\nMost of the features of bitstream are available via the \nBitStream\n class.\n\n\n from bitstream import BitStream\n\n\n\nThe module is tightly integrated with the [NumPy][NumPy] library. \nFor convenience, we import all symbols from its top-level module.\n\n\n from numpy import *\n\n\n\nOverview of Bitstream Features\n\n\n stream = BitStream()\n\n stream\n\nBLANKLINE\n\n\n stream.write(True, bool)\n\n stream\n1\n\n stream.write(False, bool)\n\n stream\n10\n\n stream.write(-128, int8)\n\n stream\n1010000000\n\n stream.write(\"AB\", str)\n\n stream\n10100000000100000101000010\n\n stream.read(bool, 2)\n[True, False]\n\n stream\n100000000100000101000010\n\n stream.read(int8, 1)\narray([-128], dtype=int8)\n\n stream\n0100000101000010\n\n stream.read(str, 2)\n'AB'\n\n stream\n\nBLANKLINE", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#overview", 
            "text": "TODO", 
            "title": "Overview"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Install wish with pip ( instructions ).    Most of the features of bitstream are available via the  BitStream  class.   from bitstream import BitStream  The module is tightly integrated with the [NumPy][NumPy] library. \nFor convenience, we import all symbols from its top-level module.   from numpy import *", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#overview-of-bitstream-features", 
            "text": "stream = BitStream()  stream BLANKLINE   stream.write(True, bool)  stream\n1  stream.write(False, bool)  stream\n10  stream.write(-128, int8)  stream\n1010000000  stream.write(\"AB\", str)  stream\n10100000000100000101000010  stream.read(bool, 2)\n[True, False]  stream\n100000000100000101000010  stream.read(int8, 1)\narray([-128], dtype=int8)  stream\n0100000101000010  stream.read(str, 2)\n'AB'  stream BLANKLINE", 
            "title": "Overview of Bitstream Features"
        }, 
        {
            "location": "/installation/", 
            "text": "Python 2\n\n\nBitstream supports Python 2.7.\nMake sure that the \npip\n package installer is available \nfor this version of the interpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)\n\n\n\nand install wish\n\n\n$ pip install wish\n\n\n\nPython 3\n\n\n\n\nWarning\n\n\nWish does not support Python 3 (yet).\n\n\n\n\nIf you want to install bitstream (for Python 2) \nbut \npip\n refers to your Python 3 interpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)\n\n\n\nthen you may have a version of pip for Python 2 installed.\nIt may be named \npip2\n or \npip2.7\n; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named \npython\n\n\n$ python --version\nPython 2.7.12\n\n\n\nthen install pip for Python 2 with\n\n\n$ python -m pip install --upgrade pip\n\n\n\nand finally install bitstream\n\n\n$ python -m pip install bitstream", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#python-2", 
            "text": "Bitstream supports Python 2.7.\nMake sure that the  pip  package installer is available \nfor this version of the interpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)  and install wish  $ pip install wish", 
            "title": "Python 2"
        }, 
        {
            "location": "/installation/#python-3", 
            "text": "Warning  Wish does not support Python 3 (yet).   If you want to install bitstream (for Python 2) \nbut  pip  refers to your Python 3 interpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)  then you may have a version of pip for Python 2 installed.\nIt may be named  pip2  or  pip2.7 ; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named  python  $ python --version\nPython 2.7.12  then install pip for Python 2 with  $ python -m pip install --upgrade pip  and finally install bitstream  $ python -m pip install bitstream", 
            "title": "Python 3"
        }, 
        {
            "location": "/basics/", 
            "text": "Overview of Bitstream Features\n\n\n stream = BitStream()\n\n stream\n\nBLANKLINE\n\n\n stream.write(True, bool)\n\n stream\n1\n\n stream.write(False, bool)\n\n stream\n10\n\n stream.write(-128, int8)\n\n stream\n1010000000\n\n stream.write(\"AB\", str)\n\n stream\n10100000000100000101000010\n\n stream.read(bool, 2)\n[True, False]\n\n stream\n100000000100000101000010\n\n stream.read(int8, 1)\narray([-128], dtype=int8)\n\n stream\n0100000101000010\n\n stream.read(str, 2)\n'AB'\n\n stream\n\nBLANKLINE", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#overview-of-bitstream-features", 
            "text": "stream = BitStream()  stream BLANKLINE   stream.write(True, bool)  stream\n1  stream.write(False, bool)  stream\n10  stream.write(-128, int8)  stream\n1010000000  stream.write(\"AB\", str)  stream\n10100000000100000101000010  stream.read(bool, 2)\n[True, False]  stream\n100000000100000101000010  stream.read(int8, 1)\narray([-128], dtype=int8)  stream\n0100000101000010  stream.read(str, 2)\n'AB'  stream BLANKLINE", 
            "title": "Overview of Bitstream Features"
        }, 
        {
            "location": "/types/", 
            "text": "Built-in Readers and Writers\n\n\nBools\n\n\nWrite single bits to a bitstream with the arguments \nTrue\n and \nFalse\n:\n\n\n stream = BitStream()\n\n stream.write(False, bool)\n\n stream.write(True , bool)\n\n stream\n01\n\n\n\nLists of booleans may be used too write multiple bits at once:\n\n\n stream = BitStream()\n\n stream.write([], bool)\n\n stream\n\nBLANKLINE\n\n\n stream.write([False], bool)\n\n stream.write([True] , bool)\n\n stream\n01\n\n stream.write([False, True], bool)\n\n stream\n0101\n\n\n\nThe second argument to the \nwrite\n method -- the type information -- can \nalso be specified with the keyword argument \ntype\n:\n\n\n stream = BitStream()\n\n stream.write(False, type=bool)\n\n stream.write(True , type=bool)\n\n stream\n01\n\n\n\nFor single bools or lists of bools, the type information is optional:\n\n\n stream = BitStream()\n\n stream.write(False)\n\n stream.write(True)\n\n stream.write([])\n\n stream.write([False])\n\n stream.write([True])\n\n stream.write([False, True])\n\n stream\n010101\n\n\n\nNumpy \nbool_\n scalars or one-dimensional arrays can be used instead:\n\n\n bool_\n\ntype 'numpy.bool_'\n\n\n stream = BitStream()\n\n stream.write(bool_(False)  , bool)\n\n stream.write(bool_(True)   , bool)\n\n stream\n01\n\n\n stream = BitStream()\n\n empty = array([], dtype=bool)\n\n stream.write(empty, bool)\n\n stream\n\nBLANKLINE\n\n\n stream.write(array([False]), bool)\n\n stream.write(array([True]) , bool)\n\n stream.write(array([False, True]), bool)\n\n stream\n0101\n\n\n\nFor such data, the type information is also optional:\n\n\n stream = BitStream()\n\n stream.write(bool_(False))\n\n stream.write(bool_(True))\n\n stream.write(array([], dtype=bool))\n\n stream.write(array([False]))\n\n stream.write(array([True]))\n\n stream.write(array([False, True]))\n\n stream\n010101\n\n\n\nPython and Numpy numeric types are also valid arguments: \nzero is considered false and nonzero numbers are considered true.\n\n\nQ:\n Use a predicate instead (non-zero) ? and check iff ?\n\n\n small_integers = range(0, 64)\n\n stream = BitStream()\n\n for integer in small_integers:\n...     stream.write(integer, bool)\n\n stream\n0111111111111111111111111111111111111111111111111111111111111111\n\n stream = BitStream()\n\n for integer in small_integers:\n...     stream.write(-integer, bool)\n\n stream\n0111111111111111111111111111111111111111111111111111111111111111\n\n\n large_integers = [2**i for i in range(6, 64)]\n\n stream = BitStream()\n\n for integer in large_integers:\n...     stream.write(integer, bool)\n\n stream\n1111111111111111111111111111111111111111111111111111111111\n\n stream = BitStream()\n\n for integer in large_integers:\n...     stream.write(-integer, bool)\n\n stream\n1111111111111111111111111111111111111111111111111111111111\n\n\n\nTODO:\n use iinfo(type).min/max\n\n\nTODO:\n write \nsample(type, r)\n iterator.\n\n\n def irange(start, stop, r=1.0):\n...     i = 0\n...     while i \n stop:\n...         yield i\n...         i = max(i+1, int(i*r))\n\n\n unsigned = [uint8, uint16, uint32]\n\n for integer_type in unsigned:\n...     _min, _max = iinfo(integer_type).min, iinfo(integer_type).max\n...     for i in irange(_min, _max + 1, r=1.001):\n...         integer = integer_type(i)\n...         if integer and BitStream(integer, bool) != BitStream(True):\n...             type_name = integer_type.__name__\n...             print \"Failure for {0}({1})\".format(type_name, integer)\n\n\n\n\n\n\n stream = BitStream()\n\n stream.write(0.0, bool)\n\n stream.write(1.0, bool)\n\n stream.write(pi , bool)\n\n stream.write(float64(0.0), bool)\n\n stream.write(float64(1.0), bool)\n\n stream.write(float64(pi) , bool)\n\n stream\n011011\n\n\n\nTODO:\n arrays of numeric type (non-bools), written as bools\n\n\n\n\nTODO:\n Mark all following behaviors as undefined ? Probably safer ...\n\n\nActually, any single data written as a bool, is conceptually cast into a bool \nfirst, with the semantics of the \nbool\n constructor.\nList and one-dimensional numpy array arguments are considered holders of \nmultiple data, each of which is converted to bool.\nAny other sequence type (strings, tuples, etc.) is considered single data.\n\n\n bool(\"\")\nFalse\n\n bool(\" \")\nTrue\n\n bool(\"A\")\nTrue\n\n bool(\"AAA\")\nTrue\n\n\n stream = BitStream()\n\n stream.write(\"\", bool)\n\n stream.write(\" \", bool)\n\n stream.write(\"A\", bool)\n\n stream.write(\"AAA\", bool)\n\n stream\n0111\n\n stream = BitStream()\n\n stream.write([\"\", \" \" , \"A\", \"AAA\"], bool)\n\n stream\n0111\n\n stream = BitStream()\n\n stream.write(array([\"\", \" \" , \"A\", \"AAA\"]), bool)\n\n stream\n0111\n\n\n stream = BitStream()\n\n stream.write(    (), bool)\n\n stream.write(  (0,), bool)\n\n stream.write((0, 0), bool)\n\n stream\n011\n\n\n stream = BitStream()\n\n stream.write([[], [0], [0, 0]], bool)\n\n stream\n011\n\n\n class BoolLike(object):\n...     def __init__(self, value):\n...         self.value = bool(value)\n...     def __nonzero__(self):\n...         return self.value\n\n false = BoolLike(False)\n\n true = BoolLike(True)\n\n stream = BitStream()\n\n stream.write(false, bool)\n\n stream.write(true, bool)\n\n stream.write([false, true], bool)\n\n stream\n0101\n\n\n\nTODO: \n\n\n\n\ndirect call to \nwrite_bool\n (import the symbol first)\n\n\nreader tests\n\n\n\n\nIntegers\n\n\nTODO\n\n\nFloating-Point Numbers\n\n\n import struct\n\n struct.pack(\"\nd\", pi)\n'@\\t!\\xfbTD-\\x18'\n\n\n stream = BitStream()\n\n stream.write(0.0)\n\n stream.write([1.0, 2.0, 3.0])\n\n stream.write(arange(4.0, 10.0))\n\n len(stream)\n640\n\n output = stream.read(float, 10)\n\n type(output)\n\ntype 'numpy.ndarray'\n\n\n all(output == arange(10.0))\nTrue\n\n\n BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64)\nTrue\n\n BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1))\nTrue\n\n\n\nThe byte order is big endian:\n\n\n BitStream(struct.pack(\"\nd\", pi)) == BitStream(pi)\nTrue", 
            "title": "Built-in Types"
        }, 
        {
            "location": "/types/#built-in-readers-and-writers", 
            "text": "", 
            "title": "Built-in Readers and Writers"
        }, 
        {
            "location": "/types/#bools", 
            "text": "Write single bits to a bitstream with the arguments  True  and  False :   stream = BitStream()  stream.write(False, bool)  stream.write(True , bool)  stream\n01  Lists of booleans may be used too write multiple bits at once:   stream = BitStream()  stream.write([], bool)  stream BLANKLINE   stream.write([False], bool)  stream.write([True] , bool)  stream\n01  stream.write([False, True], bool)  stream\n0101  The second argument to the  write  method -- the type information -- can \nalso be specified with the keyword argument  type :   stream = BitStream()  stream.write(False, type=bool)  stream.write(True , type=bool)  stream\n01  For single bools or lists of bools, the type information is optional:   stream = BitStream()  stream.write(False)  stream.write(True)  stream.write([])  stream.write([False])  stream.write([True])  stream.write([False, True])  stream\n010101  Numpy  bool_  scalars or one-dimensional arrays can be used instead:   bool_ type 'numpy.bool_'   stream = BitStream()  stream.write(bool_(False)  , bool)  stream.write(bool_(True)   , bool)  stream\n01  stream = BitStream()  empty = array([], dtype=bool)  stream.write(empty, bool)  stream BLANKLINE   stream.write(array([False]), bool)  stream.write(array([True]) , bool)  stream.write(array([False, True]), bool)  stream\n0101  For such data, the type information is also optional:   stream = BitStream()  stream.write(bool_(False))  stream.write(bool_(True))  stream.write(array([], dtype=bool))  stream.write(array([False]))  stream.write(array([True]))  stream.write(array([False, True]))  stream\n010101  Python and Numpy numeric types are also valid arguments: \nzero is considered false and nonzero numbers are considered true.  Q:  Use a predicate instead (non-zero) ? and check iff ?   small_integers = range(0, 64)  stream = BitStream()  for integer in small_integers:\n...     stream.write(integer, bool)  stream\n0111111111111111111111111111111111111111111111111111111111111111  stream = BitStream()  for integer in small_integers:\n...     stream.write(-integer, bool)  stream\n0111111111111111111111111111111111111111111111111111111111111111  large_integers = [2**i for i in range(6, 64)]  stream = BitStream()  for integer in large_integers:\n...     stream.write(integer, bool)  stream\n1111111111111111111111111111111111111111111111111111111111  stream = BitStream()  for integer in large_integers:\n...     stream.write(-integer, bool)  stream\n1111111111111111111111111111111111111111111111111111111111  TODO:  use iinfo(type).min/max  TODO:  write  sample(type, r)  iterator.   def irange(start, stop, r=1.0):\n...     i = 0\n...     while i   stop:\n...         yield i\n...         i = max(i+1, int(i*r))  unsigned = [uint8, uint16, uint32]  for integer_type in unsigned:\n...     _min, _max = iinfo(integer_type).min, iinfo(integer_type).max\n...     for i in irange(_min, _max + 1, r=1.001):\n...         integer = integer_type(i)\n...         if integer and BitStream(integer, bool) != BitStream(True):\n...             type_name = integer_type.__name__\n...             print \"Failure for {0}({1})\".format(type_name, integer)  stream = BitStream()  stream.write(0.0, bool)  stream.write(1.0, bool)  stream.write(pi , bool)  stream.write(float64(0.0), bool)  stream.write(float64(1.0), bool)  stream.write(float64(pi) , bool)  stream\n011011  TODO:  arrays of numeric type (non-bools), written as bools   TODO:  Mark all following behaviors as undefined ? Probably safer ...  Actually, any single data written as a bool, is conceptually cast into a bool \nfirst, with the semantics of the  bool  constructor.\nList and one-dimensional numpy array arguments are considered holders of \nmultiple data, each of which is converted to bool.\nAny other sequence type (strings, tuples, etc.) is considered single data.   bool(\"\")\nFalse  bool(\" \")\nTrue  bool(\"A\")\nTrue  bool(\"AAA\")\nTrue  stream = BitStream()  stream.write(\"\", bool)  stream.write(\" \", bool)  stream.write(\"A\", bool)  stream.write(\"AAA\", bool)  stream\n0111  stream = BitStream()  stream.write([\"\", \" \" , \"A\", \"AAA\"], bool)  stream\n0111  stream = BitStream()  stream.write(array([\"\", \" \" , \"A\", \"AAA\"]), bool)  stream\n0111  stream = BitStream()  stream.write(    (), bool)  stream.write(  (0,), bool)  stream.write((0, 0), bool)  stream\n011  stream = BitStream()  stream.write([[], [0], [0, 0]], bool)  stream\n011  class BoolLike(object):\n...     def __init__(self, value):\n...         self.value = bool(value)\n...     def __nonzero__(self):\n...         return self.value  false = BoolLike(False)  true = BoolLike(True)  stream = BitStream()  stream.write(false, bool)  stream.write(true, bool)  stream.write([false, true], bool)  stream\n0101  TODO:    direct call to  write_bool  (import the symbol first)  reader tests", 
            "title": "Bools"
        }, 
        {
            "location": "/types/#integers", 
            "text": "TODO", 
            "title": "Integers"
        }, 
        {
            "location": "/types/#floating-point-numbers", 
            "text": "import struct  struct.pack(\" d\", pi)\n'@\\t!\\xfbTD-\\x18'  stream = BitStream()  stream.write(0.0)  stream.write([1.0, 2.0, 3.0])  stream.write(arange(4.0, 10.0))  len(stream)\n640  output = stream.read(float, 10)  type(output) type 'numpy.ndarray'   all(output == arange(10.0))\nTrue  BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64)\nTrue  BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1))\nTrue  The byte order is big endian:   BitStream(struct.pack(\" d\", pi)) == BitStream(pi)\nTrue", 
            "title": "Floating-Point Numbers"
        }, 
        {
            "location": "/custom/", 
            "text": "Custom Writers and Readers\n\n\n import bitstream\n\n\n\nDefinition and Registration of Writers and Readers\n\n\nLet's define a writer for the binary representation of natural numbers:\n\n\n def write_integer(stream, data):\n...     if isinstance(data, list):\n...         for integer in data:\n...             write_integer(stream, integer)\n...     else:\n...         integer = int(data)\n...         if integer \n 0:\n...             error = \"negative integers cannot be encoded\"\n...             raise ValueError(error)\n...         bools = []\n...         while integer:\n...             bools.append(integer \n 1)\n...             integer = integer \n 1\n...         bools.reverse()\n...         stream.write(bools, bool)\n\n\n\nWe can check that this writer behaves as expected:\n\n\n stream = BitStream()\n\n write_integer(stream, 42)\n\n stream\n101010\n\n write_integer(stream, [1, 2, 3])\n\n stream\n10101011011\n\n\n\nThen, we can associate it to the type \nint\n:\n\n\n bitstream.register(int, writer=write_integer)\n\n\n\nAfter this step, \nBitStream\n will redirect all data of type \nint\n to this writer:\n\n\n BitStream(42)\n101010\n\n BitStream([1, 2, 3])\n11011\n\n\n\nIf the type information is explicit, other kind of data can use this writer too:\n\n\n BitStream(uint8(42), int)\n101010\n\n BitStream(\"42\", int)\n101010\n\n\n\nA possible implementation of the corresponding reader is given by:\n\n\n def read_integer(stream, n=None):\n...     if n is not None:\n...         error = \"unsupported argument n\"\n...         raise NotImplementedError(error)\n...     else:\n...         integer = 0\n...         for _ in range(len(stream)):\n...             integer = integer \n 1\n...             if stream.read(bool):\n...                 integer += 1\n...     return integer\n\n\n read_integer(BitStream(42))\n42\n\n\n\nOnce this reader is registered with\n\n\n bitstream.register(int, reader=read_integer)\n\n\n\nthe calls to \nread_integer\n can be made through the \nread\n method of \nBitStream\n.\n\n\n BitStream(42).read(int)\n42\n\n\n\nIn all readers, the second argument of readers, named \nn\n, \nrepresents the number of values to read from the stream. \nHere, this argument is not supported, instead any call to this reader \ninterprets the complete stream content as a single value.\n\n\nWriter and Reader Factories\n\n\nWe actually had a legitimate reason not to support the number of values argument \nin the binary representation reader. Indeed, when the binary representation \nis used to code sequence of integers instead of a single integer, it becomes \nambiguous: the same bitstream may represent several sequences of integers. \nFor example, we have:\n\n\n BitStream(255)\n11111111\n\n BitStream([15, 15])\n11111111\n\n BitStream([3, 7, 3, 1])\n11111111\n\n BitStream([3, 3, 3, 3])\n11111111\n\n\n\nWe say that this code is not \nself-delimiting\n, as there is no way to know \nwhere is the boundary between the bits coding for different integers. \n\n\nFor natural numbers with known bounds, we may solve this problem by setting\na number of bits to be used for each integer. However, to do that, we\nwould have to define and register a new writer for every possible number\nof bits. Instead, we register a single but configurable writer, defined\nby a writer factory.\n\n\nLet's define a type tag \nuint\n whose instances hold a number of bits:\n\n\n class uint(object):\n...     def __init__(self, num_bits):\n...         self.num_bits = num_bits\n\n\n\nThen, we define a factory that given a \nuint\n instance, \nreturns a stream writer:\n\n\n def write_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def write_uint(stream, data):\n...         if isinstance(data, list):\n...             for integer in data:\n...                 write_uint(stream, integer)\n...         else:\n...             integer = int(data)\n...             if integer \n 0:\n...                 error = \"negative integers cannot be encoded\"\n...                 raise ValueError(error)\n...             bools = []\n...             for _ in range(num_bits):\n...                 bools.append(integer \n 1)\n...                 integer = integer \n 1\n...             bools.reverse()\n...             stream.write(bools, bool)\n...     return write_uint\n\n\n\nFinally, we register this writer factory with \nbitstream\n:\n\n\n bitstream.register(uint, writer=write_uint_factory)\n\n\n\nTo select a writer, we use the proper instance of type tag:\n\n\n BitStream(255, uint(8))\n11111111\n\n BitStream(255, uint(16))\n0000000011111111\n\n BitStream(42, uint(8))\n00101010\n\n BitStream(0, uint(16))\n0000000000000000\n\n\n\nTODO: reader, give details, comment.\n\n\n def read_uint_factory(instance): # use the name factory ?\n...     num_bits = instance.num_bits\n...     def read_uint(stream, n=None):\n...         if n is None:\n...             integer = 0\n...             for _ in range(num_bits):\n...                 integer = integer \n 1\n...                 if stream.read(bool):\n...                     integer += 1\n...             return integer\n...         else:\n...             integers = [read_uint(stream) for _ in range(n)]\n...             return integers\n...     return read_uint\n\n\n bitstream.register(uint, reader=read_uint_factory)\n\n\n stream = BitStream([0, 1, 2, 3, 4], uint(8))\n\n stream.read(uint(8))\n0\n\n stream.read(uint(8), 1)\n[1]\n\n stream.read(uint(8), 3)\n[2, 3, 4]", 
            "title": "Custom Types"
        }, 
        {
            "location": "/custom/#custom-writers-and-readers", 
            "text": "import bitstream", 
            "title": "Custom Writers and Readers"
        }, 
        {
            "location": "/custom/#definition-and-registration-of-writers-and-readers", 
            "text": "Let's define a writer for the binary representation of natural numbers:   def write_integer(stream, data):\n...     if isinstance(data, list):\n...         for integer in data:\n...             write_integer(stream, integer)\n...     else:\n...         integer = int(data)\n...         if integer   0:\n...             error = \"negative integers cannot be encoded\"\n...             raise ValueError(error)\n...         bools = []\n...         while integer:\n...             bools.append(integer   1)\n...             integer = integer   1\n...         bools.reverse()\n...         stream.write(bools, bool)  We can check that this writer behaves as expected:   stream = BitStream()  write_integer(stream, 42)  stream\n101010  write_integer(stream, [1, 2, 3])  stream\n10101011011  Then, we can associate it to the type  int :   bitstream.register(int, writer=write_integer)  After this step,  BitStream  will redirect all data of type  int  to this writer:   BitStream(42)\n101010  BitStream([1, 2, 3])\n11011  If the type information is explicit, other kind of data can use this writer too:   BitStream(uint8(42), int)\n101010  BitStream(\"42\", int)\n101010  A possible implementation of the corresponding reader is given by:   def read_integer(stream, n=None):\n...     if n is not None:\n...         error = \"unsupported argument n\"\n...         raise NotImplementedError(error)\n...     else:\n...         integer = 0\n...         for _ in range(len(stream)):\n...             integer = integer   1\n...             if stream.read(bool):\n...                 integer += 1\n...     return integer  read_integer(BitStream(42))\n42  Once this reader is registered with   bitstream.register(int, reader=read_integer)  the calls to  read_integer  can be made through the  read  method of  BitStream .   BitStream(42).read(int)\n42  In all readers, the second argument of readers, named  n , \nrepresents the number of values to read from the stream. \nHere, this argument is not supported, instead any call to this reader \ninterprets the complete stream content as a single value.", 
            "title": "Definition and Registration of Writers and Readers"
        }, 
        {
            "location": "/custom/#writer-and-reader-factories", 
            "text": "We actually had a legitimate reason not to support the number of values argument \nin the binary representation reader. Indeed, when the binary representation \nis used to code sequence of integers instead of a single integer, it becomes \nambiguous: the same bitstream may represent several sequences of integers. \nFor example, we have:   BitStream(255)\n11111111  BitStream([15, 15])\n11111111  BitStream([3, 7, 3, 1])\n11111111  BitStream([3, 3, 3, 3])\n11111111  We say that this code is not  self-delimiting , as there is no way to know \nwhere is the boundary between the bits coding for different integers.   For natural numbers with known bounds, we may solve this problem by setting\na number of bits to be used for each integer. However, to do that, we\nwould have to define and register a new writer for every possible number\nof bits. Instead, we register a single but configurable writer, defined\nby a writer factory.  Let's define a type tag  uint  whose instances hold a number of bits:   class uint(object):\n...     def __init__(self, num_bits):\n...         self.num_bits = num_bits  Then, we define a factory that given a  uint  instance, \nreturns a stream writer:   def write_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def write_uint(stream, data):\n...         if isinstance(data, list):\n...             for integer in data:\n...                 write_uint(stream, integer)\n...         else:\n...             integer = int(data)\n...             if integer   0:\n...                 error = \"negative integers cannot be encoded\"\n...                 raise ValueError(error)\n...             bools = []\n...             for _ in range(num_bits):\n...                 bools.append(integer   1)\n...                 integer = integer   1\n...             bools.reverse()\n...             stream.write(bools, bool)\n...     return write_uint  Finally, we register this writer factory with  bitstream :   bitstream.register(uint, writer=write_uint_factory)  To select a writer, we use the proper instance of type tag:   BitStream(255, uint(8))\n11111111  BitStream(255, uint(16))\n0000000011111111  BitStream(42, uint(8))\n00101010  BitStream(0, uint(16))\n0000000000000000  TODO: reader, give details, comment.   def read_uint_factory(instance): # use the name factory ?\n...     num_bits = instance.num_bits\n...     def read_uint(stream, n=None):\n...         if n is None:\n...             integer = 0\n...             for _ in range(num_bits):\n...                 integer = integer   1\n...                 if stream.read(bool):\n...                     integer += 1\n...             return integer\n...         else:\n...             integers = [read_uint(stream) for _ in range(n)]\n...             return integers\n...     return read_uint  bitstream.register(uint, reader=read_uint_factory)  stream = BitStream([0, 1, 2, 3, 4], uint(8))  stream.read(uint(8))\n0  stream.read(uint(8), 1)\n[1]  stream.read(uint(8), 3)\n[2, 3, 4]", 
            "title": "Writer and Reader Factories"
        }, 
        {
            "location": "/snapshots/", 
            "text": "Snapshots (Bitstream state)\n\n\n(random thought for the moment, fondations for the design of snapshots:)\n\n\nTODO:\n sort doc material vs dev comments, dispatch, polish.\n\n\nterms: snapshot (state ?), save, restore.\n\n\nGoals:\n \n\n\n\n\n\n\nfor the implementation and error API point of view: give a mechanism to roll\n    back all operations that may end up with a \"corrupted\" stream (stream\n    content has changed but cannot deliver what the read asked for), so\n    that the mere error scheme that we have now on reader can be upgraded\n    to a real exception handling mechansim: if a read fails, the stream\n    state hasn't changed.\n\n\n\n\n\n\noffer the user with read-only and on-demand roll-back features.\n\n\n\n\n\n\nAdd \nsave\n (returns a (read_offset, write_offset) state) and \nrestore\n\n(with state as an argument) or \nload\n ? We leverage the fact in our\nstream model, the data is not immutable, but no information is lost,\nonly added at the end, so we may always roll back if we need too.\n\n\nThese two methods shall enable a true exception management (not mere\nerrors, when shit happens, we still have a usable state), AND at the\nsame time, read-only streams. Maybe higher-level constructs (with\ncontext manager ?) could be useful here to exploit those two schemes.\n\n\nUPDATE: if we want the save / restor NOT TO CRASH, we have to ensure of two\nthings\n\n\n\n\n\n\nfirst that the state stores the id of the stream ... you can't\n    restore a state that was not created by you.\n\n\n\n\n\n\nsecondly, as restore + write break the immutability of the stream,\n    save/restore pairs should only be applied in reverse order, with\n    possible drops in the restore. That should be check by the stream.\n    What I mean is that save 1, save 2, restore 2, restore 1 os OK,\n    S1, S2, R1 is ok, but S1, S2, R1, S2 is not.\n\n\n\n\n\n\nDesign: \nState\n class with ref to the stream attribute, \nread_offset\n,\n\nwrite_offset\n, implements the comparison (?). Not that simple. The idea\nbehind the comparison is that you should always be able to restore an\nOLDER snapshot but actually if you think of it, that's older in the \nstory of emission of snapshots. So you also have to embed a snapshot \nnumber and base your comparison on that. As a consequence, bitstream\ninstances have nothing to store but a snapshot number (the number of\nthe snapshot that was emitted, or 0 if no snapshot was). No, this is\nmore complex, requires some thinking. Need to track all restorable\nstates in the stream ? Maybe ...\n\n\nTODO.\n basic doctest.\n\n\n stream = BitStream()\n\n s0 = stream.save()\n\n stream.write(\"A\")\n\n s1 = stream.save()\n\n stream.write(\"B\")\n\n s2 = stream.save()\n\n stream.restore(s1)\n\n stream == BitStream(\"A\")\nTrue\n\n stream.restore(s2) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ...\n\n stream.write(\"C\")\n\n stream == BitStream(\"AC\")\nTrue\n\n s3 = stream.save()\n\n stream.restore(s1)\n\n stream == BitStream(\"A\")\nTrue\n\n stream.restore(s0)\n\n stream == BitStream(\"\")\nTrue\n\n\n\nMost useful patterns: \n\n\nAvoid copies.\n Do read/write stuff on a stream and when you're done, \nrestore the original stream intact. Here the snapshot approach avoids a \ncopy of the bitstream. The pattern is a \ntry/finally\n with a snapshot\nrestore in the finally clause.\n\n\n stream = BitStream(\"ABC\")\n\n snapshot = stream.save()\n\n try:\n...     # turn \"ABC\" into \"BCD\"\n...     _ = stream.read(str, 1)\n...     stream.write(\"D\")\n... finally:\n...     stream.restore(snapshot)\n\n stream == BitStream(\"ABC\")\nTrue\n\n\n\nIf an exception can be raised during the read/write, the stream is still \nrestored in the original state.\n\n\n from bitstream import ReadError\n\n stream = BitStream(\"ABC\")\n\n snapshot = stream.save()\n\n try:\n...     # read too much data\n...     _ = stream.read(str, 4)\n... except ReadError:\n...     pass\n... finally:\n...     stream.restore(snapshot)\n\n stream == BitStream(\"ABC\")\nTrue\n\n\n\nRemark: the pattern breaks if during the actions, an earlier snapshot is restored.\n\n\nSupport true exceptions in readers.\n Som reading actions may fail, but you\nare not able to tell beforehand, you have to start a sequence of smaller\nreads before you know of the big read call is going to work. A reader with a\nproper exception support will restore the orginal state of the stream before \nraising the exception if something goes wrong. Typically, that means a reader\ncode with the structure:\n\n\n def reader(stream, n=None):\n...     snapshot = stream.save()\n...     try:\n...         pass # do what you have to do.\n...     except ReadError: \n...         stream.restore(snapshot)\n...         raise\n\n\n\nMake convenience functions (with context managers) for those use cases ?\nFor the \"light-weight copy\" that would be easy (under what name ?) but \nfor the reader, that's not obvious, the reader developer may be willing\nto analyze the error and customize the error message before a re-raise ...", 
            "title": "Snapshots"
        }, 
        {
            "location": "/snapshots/#snapshots-bitstream-state", 
            "text": "(random thought for the moment, fondations for the design of snapshots:)  TODO:  sort doc material vs dev comments, dispatch, polish.  terms: snapshot (state ?), save, restore.  Goals:      for the implementation and error API point of view: give a mechanism to roll\n    back all operations that may end up with a \"corrupted\" stream (stream\n    content has changed but cannot deliver what the read asked for), so\n    that the mere error scheme that we have now on reader can be upgraded\n    to a real exception handling mechansim: if a read fails, the stream\n    state hasn't changed.    offer the user with read-only and on-demand roll-back features.    Add  save  (returns a (read_offset, write_offset) state) and  restore \n(with state as an argument) or  load  ? We leverage the fact in our\nstream model, the data is not immutable, but no information is lost,\nonly added at the end, so we may always roll back if we need too.  These two methods shall enable a true exception management (not mere\nerrors, when shit happens, we still have a usable state), AND at the\nsame time, read-only streams. Maybe higher-level constructs (with\ncontext manager ?) could be useful here to exploit those two schemes.  UPDATE: if we want the save / restor NOT TO CRASH, we have to ensure of two\nthings    first that the state stores the id of the stream ... you can't\n    restore a state that was not created by you.    secondly, as restore + write break the immutability of the stream,\n    save/restore pairs should only be applied in reverse order, with\n    possible drops in the restore. That should be check by the stream.\n    What I mean is that save 1, save 2, restore 2, restore 1 os OK,\n    S1, S2, R1 is ok, but S1, S2, R1, S2 is not.    Design:  State  class with ref to the stream attribute,  read_offset , write_offset , implements the comparison (?). Not that simple. The idea\nbehind the comparison is that you should always be able to restore an\nOLDER snapshot but actually if you think of it, that's older in the \nstory of emission of snapshots. So you also have to embed a snapshot \nnumber and base your comparison on that. As a consequence, bitstream\ninstances have nothing to store but a snapshot number (the number of\nthe snapshot that was emitted, or 0 if no snapshot was). No, this is\nmore complex, requires some thinking. Need to track all restorable\nstates in the stream ? Maybe ...  TODO.  basic doctest.   stream = BitStream()  s0 = stream.save()  stream.write(\"A\")  s1 = stream.save()  stream.write(\"B\")  s2 = stream.save()  stream.restore(s1)  stream == BitStream(\"A\")\nTrue  stream.restore(s2) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ...  stream.write(\"C\")  stream == BitStream(\"AC\")\nTrue  s3 = stream.save()  stream.restore(s1)  stream == BitStream(\"A\")\nTrue  stream.restore(s0)  stream == BitStream(\"\")\nTrue  Most useful patterns:   Avoid copies.  Do read/write stuff on a stream and when you're done, \nrestore the original stream intact. Here the snapshot approach avoids a \ncopy of the bitstream. The pattern is a  try/finally  with a snapshot\nrestore in the finally clause.   stream = BitStream(\"ABC\")  snapshot = stream.save()  try:\n...     # turn \"ABC\" into \"BCD\"\n...     _ = stream.read(str, 1)\n...     stream.write(\"D\")\n... finally:\n...     stream.restore(snapshot)  stream == BitStream(\"ABC\")\nTrue  If an exception can be raised during the read/write, the stream is still \nrestored in the original state.   from bitstream import ReadError  stream = BitStream(\"ABC\")  snapshot = stream.save()  try:\n...     # read too much data\n...     _ = stream.read(str, 4)\n... except ReadError:\n...     pass\n... finally:\n...     stream.restore(snapshot)  stream == BitStream(\"ABC\")\nTrue  Remark: the pattern breaks if during the actions, an earlier snapshot is restored.  Support true exceptions in readers.  Som reading actions may fail, but you\nare not able to tell beforehand, you have to start a sequence of smaller\nreads before you know of the big read call is going to work. A reader with a\nproper exception support will restore the orginal state of the stream before \nraising the exception if something goes wrong. Typically, that means a reader\ncode with the structure:   def reader(stream, n=None):\n...     snapshot = stream.save()\n...     try:\n...         pass # do what you have to do.\n...     except ReadError: \n...         stream.restore(snapshot)\n...         raise  Make convenience functions (with context managers) for those use cases ?\nFor the \"light-weight copy\" that would be easy (under what name ?) but \nfor the reader, that's not obvious, the reader developer may be willing\nto analyze the error and customize the error message before a re-raise ...", 
            "title": "Snapshots (Bitstream state)"
        }, 
        {
            "location": "/contribute/", 
            "text": "Contribute\n\n\nTODO:\n\n\n\n\n\n\ncontribution process (via GitHub)\n\n\n\n\n\n\nbuild the documentation\n\n\n\n\n\n\nbuild from the sources\n\n\n\n\n\n\n\n\nBitstream targets \nPython 2.7\n, you will need to install it first.\n\n\nTODO:\n move NumPy dependency here (? Dunno ...), talk about Linux-only platform.\n\n\n\n\n\n\nInstall from source:\n the releases of Bitstream are available\n    on the \nPython Package Index (PyPi)\n. Once you have \n    downloaded and unpacked the archive, to build the Bitstream module, \n    you need \nsetuptools\n.\n    You also need to install the \nNumPy\n package, version 1.6.1 or later.\n\n\nTODO: test if numpy is automatically download if needed\n.\n\n\nThen, as root, execute\n\n\n$ python setup.py install\n\n\n\n\n\n\n\nHack with git:\n to experiment with the latest version of Bitstream, \n    clone the GitHub repository:\n\n\n$ git clone git://github.com/boisgera/bitstream.git\n\n\n\nTo actually build the module, you will need everything you need to build\nfrom source and will execute the same command. If in addition, you want\nto edit the source files, you will also need the [Cython][] compiler, \nversion 0.15.1 or later and will execute instead:\n\n\n$ python setup.py install --cython", 
            "title": "Contribute"
        }, 
        {
            "location": "/contribute/#contribute", 
            "text": "TODO:    contribution process (via GitHub)    build the documentation    build from the sources     Bitstream targets  Python 2.7 , you will need to install it first.  TODO:  move NumPy dependency here (? Dunno ...), talk about Linux-only platform.    Install from source:  the releases of Bitstream are available\n    on the  Python Package Index (PyPi) . Once you have \n    downloaded and unpacked the archive, to build the Bitstream module, \n    you need  setuptools .\n    You also need to install the  NumPy  package, version 1.6.1 or later.  TODO: test if numpy is automatically download if needed .  Then, as root, execute  $ python setup.py install    Hack with git:  to experiment with the latest version of Bitstream, \n    clone the GitHub repository:  $ git clone git://github.com/boisgera/bitstream.git  To actually build the module, you will need everything you need to build\nfrom source and will execute the same command. If in addition, you want\nto edit the source files, you will also need the [Cython][] compiler, \nversion 0.15.1 or later and will execute instead:  $ python setup.py install --cython", 
            "title": "Contribute"
        }
    ]
}