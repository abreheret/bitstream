{
    "docs": [
        {
            "location": "/overview/", 
            "text": "Overview\n\n\nStatement of need\n\n\nState of the art, links, etc.\n\n\nWhere to go next\n\n\n\n\nBitstream provides a binary data type with a stream interface \nfor \nPython\n.\n\n\n\n\n\n\nBinary Data:\n the \nBitStream\n class is a linearly ordered container of bits.\n    The standard library is only convenient to manage binary data at the byte level. \n    Consider using BitStream instead, especially you need to address the bit level.\n\n\n\n\n\n\nStream Interface:\n you can only read data at the start of a stream \n    and write data at its end.\n    This is a very simple way to interact with binary data, but it is also\n    the pattern that comes naturally in many applications. To manage\n    binary codes and formats, in my experience, random data access is \n    not a requirement.\n\n\n\n\n\n\nPython and Numpy Types.\n BitStream has built-in readers and writers\n    for the common data types with a standard binary layout: bools, \n    ASCII strings, fixed-size integers and floating-point integers. \n\n\n\n\n\n\nUser-Defined Types.\n The list of supported types and binary \n    representation may be enlarged at will: new readers and writers \n    can be implemented and associated to specific data types.\n\n\n\n\n\n\nPerformance.\n Bitstream is a Python C-extension module that has been\n    optimized for the common use cases. Hopefully, it will be fast enough \n    for your needs ! Under the hood, the \nCython\n language and compiler \n    are used to generate this extension module.\n\n\n\n\n\n\nOpen-Source:\n the Bitstream software is distributed under a [MIT license]\n    \nMIT\n, its documentation under a [Creative Commons Attribution 3.0] \n    \nCC-BY-3.0\n license. The development takes place on [GitHub] [] and \n    releases are also available on [PyPi] [].", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#overview", 
            "text": "Statement of need  State of the art, links, etc.  Where to go next   Bitstream provides a binary data type with a stream interface \nfor  Python .    Binary Data:  the  BitStream  class is a linearly ordered container of bits.\n    The standard library is only convenient to manage binary data at the byte level. \n    Consider using BitStream instead, especially you need to address the bit level.    Stream Interface:  you can only read data at the start of a stream \n    and write data at its end.\n    This is a very simple way to interact with binary data, but it is also\n    the pattern that comes naturally in many applications. To manage\n    binary codes and formats, in my experience, random data access is \n    not a requirement.    Python and Numpy Types.  BitStream has built-in readers and writers\n    for the common data types with a standard binary layout: bools, \n    ASCII strings, fixed-size integers and floating-point integers.     User-Defined Types.  The list of supported types and binary \n    representation may be enlarged at will: new readers and writers \n    can be implemented and associated to specific data types.    Performance.  Bitstream is a Python C-extension module that has been\n    optimized for the common use cases. Hopefully, it will be fast enough \n    for your needs ! Under the hood, the  Cython  language and compiler \n    are used to generate this extension module.    Open-Source:  the Bitstream software is distributed under a [MIT license]\n     MIT , its documentation under a [Creative Commons Attribution 3.0] \n     CC-BY-3.0  license. The development takes place on [GitHub] [] and \n    releases are also available on [PyPi] [].", 
            "title": "Overview"
        }, 
        {
            "location": "/", 
            "text": "Binary Data Stream\n\n\nOverview\n\n\nTODO\n\n\nQuickstart\n\n\n\n\nInstall wish with pip (\ninstructions\n).\n\n\n\n\n\n\nMost of the features of bitstream are available via the \nBitStream\n class.\n\n\n from bitstream import BitStream\n\n\n\nThe module is tightly integrated with the [NumPy][NumPy] library. \nFor convenience, we import all symbols from its top-level module.\n\n\n from numpy import *\n\n\n\nOverview of Bitstream Features\n\n\n stream = BitStream()\n\n stream\n\nBLANKLINE\n\n\n stream.write(True, bool)\n\n stream\n1\n\n stream.write(False, bool)\n\n stream\n10\n\n stream.write(-128, int8)\n\n stream\n1010000000\n\n stream.write(\"AB\", str)\n\n stream\n10100000000100000101000010\n\n stream.read(bool, 2)\n[True, False]\n\n stream\n100000000100000101000010\n\n stream.read(int8, 1)\narray([-128], dtype=int8)\n\n stream\n0100000101000010\n\n stream.read(str, 2)\n'AB'\n\n stream\n\nBLANKLINE", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#overview", 
            "text": "TODO", 
            "title": "Overview"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Install wish with pip ( instructions ).    Most of the features of bitstream are available via the  BitStream  class.   from bitstream import BitStream  The module is tightly integrated with the [NumPy][NumPy] library. \nFor convenience, we import all symbols from its top-level module.   from numpy import *", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#overview-of-bitstream-features", 
            "text": "stream = BitStream()  stream BLANKLINE   stream.write(True, bool)  stream\n1  stream.write(False, bool)  stream\n10  stream.write(-128, int8)  stream\n1010000000  stream.write(\"AB\", str)  stream\n10100000000100000101000010  stream.read(bool, 2)\n[True, False]  stream\n100000000100000101000010  stream.read(int8, 1)\narray([-128], dtype=int8)  stream\n0100000101000010  stream.read(str, 2)\n'AB'  stream BLANKLINE", 
            "title": "Overview of Bitstream Features"
        }, 
        {
            "location": "/installation/", 
            "text": "Python 2\n\n\nBitstream supports Python 2.7.\nMake sure that the \npip\n package installer is available \nfor this version of the interpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)\n\n\n\nand install wish\n\n\n$ pip install wish\n\n\n\nPython 3\n\n\n\n\nWarning\n\n\nWish does not support Python 3 (yet).\n\n\n\n\nIf you want to install bitstream (for Python 2) \nbut \npip\n refers to your Python 3 interpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)\n\n\n\nthen you may have a version of pip for Python 2 installed.\nIt may be named \npip2\n or \npip2.7\n; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named \npython\n\n\n$ python --version\nPython 2.7.12\n\n\n\nthen install pip for Python 2 with\n\n\n$ python -m pip install --upgrade pip\n\n\n\nand finally install bitstream\n\n\n$ python -m pip install bitstream", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#python-2", 
            "text": "Bitstream supports Python 2.7.\nMake sure that the  pip  package installer is available \nfor this version of the interpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)  and install wish  $ pip install wish", 
            "title": "Python 2"
        }, 
        {
            "location": "/installation/#python-3", 
            "text": "Warning  Wish does not support Python 3 (yet).   If you want to install bitstream (for Python 2) \nbut  pip  refers to your Python 3 interpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)  then you may have a version of pip for Python 2 installed.\nIt may be named  pip2  or  pip2.7 ; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named  python  $ python --version\nPython 2.7.12  then install pip for Python 2 with  $ python -m pip install --upgrade pip  and finally install bitstream  $ python -m pip install bitstream", 
            "title": "Python 3"
        }, 
        {
            "location": "/basics/", 
            "text": "Overview of Bitstream Features\n\n\n stream = BitStream()\n\n stream\n\nBLANKLINE\n\n\n stream.write(True, bool)\n\n stream\n1\n\n stream.write(False, bool)\n\n stream\n10\n\n stream.write(-128, int8)\n\n stream\n1010000000\n\n stream.write(\"AB\", str)\n\n stream\n10100000000100000101000010\n\n stream.read(bool, 2)\n[True, False]\n\n stream\n100000000100000101000010\n\n stream.read(int8, 1)\narray([-128], dtype=int8)\n\n stream\n0100000101000010\n\n stream.read(str, 2)\n'AB'\n\n stream\n\nBLANKLINE", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#overview-of-bitstream-features", 
            "text": "stream = BitStream()  stream BLANKLINE   stream.write(True, bool)  stream\n1  stream.write(False, bool)  stream\n10  stream.write(-128, int8)  stream\n1010000000  stream.write(\"AB\", str)  stream\n10100000000100000101000010  stream.read(bool, 2)\n[True, False]  stream\n100000000100000101000010  stream.read(int8, 1)\narray([-128], dtype=int8)  stream\n0100000101000010  stream.read(str, 2)\n'AB'  stream BLANKLINE", 
            "title": "Overview of Bitstream Features"
        }, 
        {
            "location": "/types/", 
            "text": "Built-in Readers and Writers\n\n\n from bitstream import BitStream\n\n from numpy import *\n\n\n\nBools\n\n\nWrite single bits to a bitstream with the arguments \nTrue\n and \nFalse\n:\n\n\n stream = BitStream()\n\n stream.write(False, bool)\n\n stream.write(True , bool)\n\n stream\n01\n\n\n\nRead them back in the same order with\n\n\n stream.read(bool)\nFalse\n\n stream.read(bool)\nTrue\n\n stream\n\nBLANKLINE\n\n\n\n\nWrite multiple bits at once with lists of bools:\n\n\n stream = BitStream()\n\n stream.write([], bool)\n\n stream\n\nBLANKLINE\n\n\n stream.write([False], bool)\n\n stream.write([True] , bool)\n\n stream\n01\n\n stream.write([False, True], bool)\n\n stream\n0101\n\n\n\nAlternatively, specify the data type \nbool\n as a a keyword argument:\n\n\n stream = BitStream()\n\n stream.write(False, type=bool)\n\n stream.write(True , type=bool)\n\n stream\n01\n\n\n\nFor single bools or lists of bools, this type information is optional:\n\n\n stream = BitStream()\n\n stream.write(False)\n\n stream.write(True)\n\n stream.write([])\n\n stream.write([False])\n\n stream.write([True])\n\n stream.write([False, True])\n\n stream\n010101\n\n\n\nTo read one boolean from a stream, do\n\n\n stream.read(bool)\nFalse\n\n stream\n10101\n\n\n\nand to read several booleans, use the second method argument\n\n\n stream.read(bool, 2)\n[True, False]\n\n stream\n101\n\n\n\nSince the booleans are returned in a list when the second argument \ndiffers from the default value (which is \nNone\n), \n\nstream.read(bool, 1)\n is not same as \nstream.read(bool)\n:\n\n\n copy = stream.copy()\n\n stream.read(bool, 1)\n[True]\n\n copy.read(bool)\nTrue\n\n\n\n\n\nNumpy \nbool_\n scalars or one-dimensional arrays can be used instead:\n\n\n bool_\n\ntype 'numpy.bool_'\n\n\n stream = BitStream()\n\n stream.write(bool_(False)  , bool)\n\n stream.write(bool_(True)   , bool)\n\n stream\n01\n\n\n stream = BitStream()\n\n empty = array([], dtype=bool)\n\n stream.write(empty, bool)\n\n stream\n\nBLANKLINE\n\n\n stream.write(array([False]), bool)\n\n stream.write(array([True]) , bool)\n\n stream.write(array([False, True]), bool)\n\n stream\n0101\n\n\n\nFor such data, the type information is also optional:\n\n\n stream = BitStream()\n\n stream.write(bool_(False))\n\n stream.write(bool_(True))\n\n stream.write(array([], dtype=bool))\n\n stream.write(array([False]))\n\n stream.write(array([True]))\n\n stream.write(array([False, True]))\n\n stream\n010101\n\n\n\nActually, many more types can be used as booleans \nwhen the type information is explicit.\nFor example, Python and Numpy numeric types are valid arguments: \nzero is considered false and nonzero numbers are considered true.\n\n\n stream = BitStream()\n\n stream.write(0.0, bool)\n\n stream.write(1.0, bool)\n\n stream.write(pi , bool)\n\n stream.write(float64(0.0), bool)\n\n stream.write(float64(1.0), bool)\n\n stream.write(float64(pi) , bool)\n\n stream\n011011\n\n\n\nStrings are also valid arguments, with a boolean value of \nTrue\n unless\nthey are empty.\nOne-dimensional lists and numpy arrays are considered holders of \nmultiple data, each of which is converted to bool.\n\n\n bool(\"\")\nFalse\n\n bool(\" \")\nTrue\n\n bool(\"A\")\nTrue\n\n bool(\"AAA\")\nTrue\n\n\n stream = BitStream()\n\n stream.write(\"\", bool)\n\n stream.write(\" \", bool)\n\n stream.write(\"A\", bool)\n\n stream.write(\"AAA\", bool)\n\n stream\n0111\n\n stream = BitStream()\n\n stream.write([\"\", \" \" , \"A\", \"AAA\"], bool)\n\n stream\n0111\n\n stream = BitStream()\n\n stream.write(array([\"\", \" \" , \"A\", \"AAA\"]), bool)\n\n stream\n0111\n\n\n\nAny other sequence (strings, tuples, lists nested in lists, etc.) \nis considered as a single datum.\n\n\n stream = BitStream()\n\n stream.write(    (), bool)\n\n stream.write(  (0,), bool)\n\n stream.write((0, 0), bool)\n\n stream\n011\n\n\n stream = BitStream()\n\n stream.write([[], [0], [0, 0]], bool)\n\n stream\n011\n\n\n\nMore generally, arbitrary custom \"bool-like\" instances, \nwhich have a \n__nonzero__\n method to handle the conversion \nto boolean, can also be used:\n\n\n class BoolLike(object):\n...     def __init__(self, value):\n...         self.value = bool(value)\n...     def __nonzero__(self):\n...         return self.value\n\n false = BoolLike(False)\n\n true = BoolLike(True)\n\n\n stream = BitStream()\n\n stream.write(false, bool)\n\n stream.write(true, bool)\n\n stream.write([false, true], bool)\n\n stream\n0101\n\n\n\nBitStreams\n\n\nA lists of bool is not the most efficient way to represent a binary stream.\nThe best type is ... an instance of \nBitStream\n of course! \n\n\nConsider the stream\n\n\n stream = BitStream()\n\n stream.write(8 * [True], bool)\n\n stream\n11111111\n\n\n\nTo read 2 bits out of \nstream\n as a bitstream, use\n\n\n stream.read(BitStream, 2)\n11\n\n\n\nSince this is a common use case, the \nBitStream\n type is assumed by default:\n\n\n new_stream = stream.read(n=2)\n\n type(new_stream) is BitStream\nTrue\n\n new_stream\n11\n\n\n\nThe simpler code below also works:\n\n\n new_stream = stream.read(2)\n\n type(new_stream) is BitStream\nTrue\n\n new_stream\n11\n\n\n\nWhen the number of items to read is also specified (\nn=None\n),\nthe read empties the stream:\n\n\n stream.read()\n11\n\n stream\n\nBLANKLINE\n\n\n\n\nStrings\n\n\nIn Python 2.7, strings are the structure of choice to represent \nbytes in memory.\nTheir type is \nstr\n (or equivalently \nbytes\n which is an alias).\nFortunately, it's straightforward to convert strings to \nbitstreams: create a stream from the string \n\"ABC\"\n with\n\n\n stream = BitStream(\"ABC\")\n\n\n\nTo be totally explicit, the code above is equivalent to:\n\n\n stream = BitStream()\n\n stream.write(\"ABC\", str)\n\n\n\nNow, the content of the stream is\n\n\n stream\n010000010100001001000011\n\n\n\nIt is the binary representation\nof the ASCII codes of the string characters,\nas unsigned 8-bit integers\n(see \nIntegers\n for more details):\n\n\n char_codes = [ord(char) for char in \"ABC\"]\n\n char_codes\n[65, 66, 67]\n\n stream == BitStream(char_codes, uint8)\nTrue\n\n\n\nNow as usual, any number of characters\n\n\n stream.read(str, 1)\n'A'\n\n\n\nWithout an explicit number of characters, the bitstream is emptied\n\n\n stream.read(str)\n'BC'\n\n\n\nbut that works only if the remaining number of bits is a multiple of 8.\n\n\n stream = BitStream(42 * [True])\n\n stream.read(str) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nReadError: ...\n\n\n\nTo accept up to seven trailing bits instead, use the more explicit code:\n\n\n stream = BitStream(42 * [True])\n\n n = len(stream) // 8\n\n n\n5\n\n stream.read(str, n)\n'\\xff\\xff\\xff\\xff\\xff'\n\n stream\n11\n\n\n\nIntegers\n\n\n\n\n\n\nstart with \nuint8\n\n\n\n\n\n\nthen \nint8\n and two's complement scheme \n reference\n\n\n\n\n\n\nthen talk about endianness (the concept), \n    our default choice (are we really portable? check)\n    and how to change it if that's not what you want.\n\n\n\n\n\n\nSupported types:\n\n\n\n\n\n\nuint8\n, \nuint16\n, \nuint32\n, \n\n\n\n\n\n\nint8\n, \nint16\n, \nint32\n,\n\n\n\n\n\n\nFloating-Point Numbers\n\n\n import struct\n\n struct.pack(\"\nd\", pi)\n'@\\t!\\xfbTD-\\x18'\n\n\n stream = BitStream()\n\n stream.write(0.0)\n\n stream.write([1.0, 2.0, 3.0])\n\n stream.write(arange(4.0, 10.0))\n\n len(stream)\n640\n\n output = stream.read(float, 10)\n\n type(output)\n\ntype 'numpy.ndarray'\n\n\n all(output == arange(10.0))\nTrue\n\n\n BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64)\nTrue\n\n BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1))\nTrue\n\n\n\nThe byte order is big endian:\n\n\n BitStream(struct.pack(\"\nd\", pi)) == BitStream(pi)\nTrue", 
            "title": "Built-in Readers/Writers"
        }, 
        {
            "location": "/types/#built-in-readers-and-writers", 
            "text": "from bitstream import BitStream  from numpy import *", 
            "title": "Built-in Readers and Writers"
        }, 
        {
            "location": "/types/#bools", 
            "text": "Write single bits to a bitstream with the arguments  True  and  False :   stream = BitStream()  stream.write(False, bool)  stream.write(True , bool)  stream\n01  Read them back in the same order with   stream.read(bool)\nFalse  stream.read(bool)\nTrue  stream BLANKLINE   Write multiple bits at once with lists of bools:   stream = BitStream()  stream.write([], bool)  stream BLANKLINE   stream.write([False], bool)  stream.write([True] , bool)  stream\n01  stream.write([False, True], bool)  stream\n0101  Alternatively, specify the data type  bool  as a a keyword argument:   stream = BitStream()  stream.write(False, type=bool)  stream.write(True , type=bool)  stream\n01  For single bools or lists of bools, this type information is optional:   stream = BitStream()  stream.write(False)  stream.write(True)  stream.write([])  stream.write([False])  stream.write([True])  stream.write([False, True])  stream\n010101  To read one boolean from a stream, do   stream.read(bool)\nFalse  stream\n10101  and to read several booleans, use the second method argument   stream.read(bool, 2)\n[True, False]  stream\n101  Since the booleans are returned in a list when the second argument \ndiffers from the default value (which is  None ),  stream.read(bool, 1)  is not same as  stream.read(bool) :   copy = stream.copy()  stream.read(bool, 1)\n[True]  copy.read(bool)\nTrue   Numpy  bool_  scalars or one-dimensional arrays can be used instead:   bool_ type 'numpy.bool_'   stream = BitStream()  stream.write(bool_(False)  , bool)  stream.write(bool_(True)   , bool)  stream\n01  stream = BitStream()  empty = array([], dtype=bool)  stream.write(empty, bool)  stream BLANKLINE   stream.write(array([False]), bool)  stream.write(array([True]) , bool)  stream.write(array([False, True]), bool)  stream\n0101  For such data, the type information is also optional:   stream = BitStream()  stream.write(bool_(False))  stream.write(bool_(True))  stream.write(array([], dtype=bool))  stream.write(array([False]))  stream.write(array([True]))  stream.write(array([False, True]))  stream\n010101  Actually, many more types can be used as booleans \nwhen the type information is explicit.\nFor example, Python and Numpy numeric types are valid arguments: \nzero is considered false and nonzero numbers are considered true.   stream = BitStream()  stream.write(0.0, bool)  stream.write(1.0, bool)  stream.write(pi , bool)  stream.write(float64(0.0), bool)  stream.write(float64(1.0), bool)  stream.write(float64(pi) , bool)  stream\n011011  Strings are also valid arguments, with a boolean value of  True  unless\nthey are empty.\nOne-dimensional lists and numpy arrays are considered holders of \nmultiple data, each of which is converted to bool.   bool(\"\")\nFalse  bool(\" \")\nTrue  bool(\"A\")\nTrue  bool(\"AAA\")\nTrue  stream = BitStream()  stream.write(\"\", bool)  stream.write(\" \", bool)  stream.write(\"A\", bool)  stream.write(\"AAA\", bool)  stream\n0111  stream = BitStream()  stream.write([\"\", \" \" , \"A\", \"AAA\"], bool)  stream\n0111  stream = BitStream()  stream.write(array([\"\", \" \" , \"A\", \"AAA\"]), bool)  stream\n0111  Any other sequence (strings, tuples, lists nested in lists, etc.) \nis considered as a single datum.   stream = BitStream()  stream.write(    (), bool)  stream.write(  (0,), bool)  stream.write((0, 0), bool)  stream\n011  stream = BitStream()  stream.write([[], [0], [0, 0]], bool)  stream\n011  More generally, arbitrary custom \"bool-like\" instances, \nwhich have a  __nonzero__  method to handle the conversion \nto boolean, can also be used:   class BoolLike(object):\n...     def __init__(self, value):\n...         self.value = bool(value)\n...     def __nonzero__(self):\n...         return self.value  false = BoolLike(False)  true = BoolLike(True)  stream = BitStream()  stream.write(false, bool)  stream.write(true, bool)  stream.write([false, true], bool)  stream\n0101", 
            "title": "Bools"
        }, 
        {
            "location": "/types/#bitstreams", 
            "text": "A lists of bool is not the most efficient way to represent a binary stream.\nThe best type is ... an instance of  BitStream  of course!   Consider the stream   stream = BitStream()  stream.write(8 * [True], bool)  stream\n11111111  To read 2 bits out of  stream  as a bitstream, use   stream.read(BitStream, 2)\n11  Since this is a common use case, the  BitStream  type is assumed by default:   new_stream = stream.read(n=2)  type(new_stream) is BitStream\nTrue  new_stream\n11  The simpler code below also works:   new_stream = stream.read(2)  type(new_stream) is BitStream\nTrue  new_stream\n11  When the number of items to read is also specified ( n=None ),\nthe read empties the stream:   stream.read()\n11  stream BLANKLINE", 
            "title": "BitStreams"
        }, 
        {
            "location": "/types/#strings", 
            "text": "In Python 2.7, strings are the structure of choice to represent \nbytes in memory.\nTheir type is  str  (or equivalently  bytes  which is an alias).\nFortunately, it's straightforward to convert strings to \nbitstreams: create a stream from the string  \"ABC\"  with   stream = BitStream(\"ABC\")  To be totally explicit, the code above is equivalent to:   stream = BitStream()  stream.write(\"ABC\", str)  Now, the content of the stream is   stream\n010000010100001001000011  It is the binary representation\nof the ASCII codes of the string characters,\nas unsigned 8-bit integers\n(see  Integers  for more details):   char_codes = [ord(char) for char in \"ABC\"]  char_codes\n[65, 66, 67]  stream == BitStream(char_codes, uint8)\nTrue  Now as usual, any number of characters   stream.read(str, 1)\n'A'  Without an explicit number of characters, the bitstream is emptied   stream.read(str)\n'BC'  but that works only if the remaining number of bits is a multiple of 8.   stream = BitStream(42 * [True])  stream.read(str) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nReadError: ...  To accept up to seven trailing bits instead, use the more explicit code:   stream = BitStream(42 * [True])  n = len(stream) // 8  n\n5  stream.read(str, n)\n'\\xff\\xff\\xff\\xff\\xff'  stream\n11", 
            "title": "Strings"
        }, 
        {
            "location": "/types/#integers", 
            "text": "start with  uint8    then  int8  and two's complement scheme   reference    then talk about endianness (the concept), \n    our default choice (are we really portable? check)\n    and how to change it if that's not what you want.    Supported types:    uint8 ,  uint16 ,  uint32 ,     int8 ,  int16 ,  int32 ,", 
            "title": "Integers"
        }, 
        {
            "location": "/types/#floating-point-numbers", 
            "text": "import struct  struct.pack(\" d\", pi)\n'@\\t!\\xfbTD-\\x18'  stream = BitStream()  stream.write(0.0)  stream.write([1.0, 2.0, 3.0])  stream.write(arange(4.0, 10.0))  len(stream)\n640  output = stream.read(float, 10)  type(output) type 'numpy.ndarray'   all(output == arange(10.0))\nTrue  BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64)\nTrue  BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1))\nTrue  The byte order is big endian:   BitStream(struct.pack(\" d\", pi)) == BitStream(pi)\nTrue", 
            "title": "Floating-Point Numbers"
        }, 
        {
            "location": "/custom/", 
            "text": "Custom Writers and Readers\n\n\n import bitstream\n\n\n\nDefinition and Registration of Writers and Readers\n\n\nLet's define a writer for the binary representation of natural numbers:\n\n\n def write_integer(stream, data):\n...     if isinstance(data, list):\n...         for integer in data:\n...             write_integer(stream, integer)\n...     else:\n...         integer = int(data)\n...         if integer \n 0:\n...             error = \"negative integers cannot be encoded\"\n...             raise ValueError(error)\n...         bools = []\n...         while integer:\n...             bools.append(integer \n 1)\n...             integer = integer \n 1\n...         bools.reverse()\n...         stream.write(bools, bool)\n\n\n\nWe can check that this writer behaves as expected:\n\n\n stream = BitStream()\n\n write_integer(stream, 42)\n\n stream\n101010\n\n write_integer(stream, [1, 2, 3])\n\n stream\n10101011011\n\n\n\nThen, we can associate it to the type \nint\n:\n\n\n bitstream.register(int, writer=write_integer)\n\n\n\nAfter this step, \nBitStream\n will redirect all data of type \nint\n to this writer:\n\n\n BitStream(42)\n101010\n\n BitStream([1, 2, 3])\n11011\n\n\n\nIf the type information is explicit, other kind of data can use this writer too:\n\n\n BitStream(uint8(42), int)\n101010\n\n BitStream(\"42\", int)\n101010\n\n\n\nA possible implementation of the corresponding reader is given by:\n\n\n def read_integer(stream, n=None):\n...     if n is not None:\n...         error = \"unsupported argument n\"\n...         raise NotImplementedError(error)\n...     else:\n...         integer = 0\n...         for _ in range(len(stream)):\n...             integer = integer \n 1\n...             if stream.read(bool):\n...                 integer += 1\n...     return integer\n\n\n read_integer(BitStream(42))\n42\n\n\n\nOnce this reader is registered with\n\n\n bitstream.register(int, reader=read_integer)\n\n\n\nthe calls to \nread_integer\n can be made through the \nread\n method of \nBitStream\n.\n\n\n BitStream(42).read(int)\n42\n\n\n\nIn all readers, the second argument of readers, named \nn\n, \nrepresents the number of values to read from the stream. \nHere, this argument is not supported, instead any call to this reader \ninterprets the complete stream content as a single value.\n\n\nWriter and Reader Factories\n\n\nWe actually had a legitimate reason not to support the number of values argument \nin the binary representation reader. Indeed, when the binary representation \nis used to code sequence of integers instead of a single integer, it becomes \nambiguous: the same bitstream may represent several sequences of integers. \nFor example, we have:\n\n\n BitStream(255)\n11111111\n\n BitStream([15, 15])\n11111111\n\n BitStream([3, 7, 3, 1])\n11111111\n\n BitStream([3, 3, 3, 3])\n11111111\n\n\n\nWe say that this code is not \nself-delimiting\n, as there is no way to know \nwhere is the boundary between the bits coding for different integers. \n\n\nFor natural numbers with known bounds, we may solve this problem by setting\na number of bits to be used for each integer. However, to do that, we\nwould have to define and register a new writer for every possible number\nof bits. Instead, we register a single but configurable writer, defined\nby a writer factory.\n\n\nLet's define a type tag \nuint\n whose instances hold a number of bits:\n\n\n class uint(object):\n...     def __init__(self, num_bits):\n...         self.num_bits = num_bits\n\n\n\nThen, we define a factory that given a \nuint\n instance, \nreturns a stream writer:\n\n\n def write_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def write_uint(stream, data):\n...         if isinstance(data, list):\n...             for integer in data:\n...                 write_uint(stream, integer)\n...         else:\n...             integer = int(data)\n...             if integer \n 0:\n...                 error = \"negative integers cannot be encoded\"\n...                 raise ValueError(error)\n...             bools = []\n...             for _ in range(num_bits):\n...                 bools.append(integer \n 1)\n...                 integer = integer \n 1\n...             bools.reverse()\n...             stream.write(bools, bool)\n...     return write_uint\n\n\n\nFinally, we register this writer factory with \nbitstream\n:\n\n\n bitstream.register(uint, writer=write_uint_factory)\n\n\n\nTo select a writer, we use the proper instance of type tag:\n\n\n BitStream(255, uint(8))\n11111111\n\n BitStream(255, uint(16))\n0000000011111111\n\n BitStream(42, uint(8))\n00101010\n\n BitStream(0, uint(16))\n0000000000000000\n\n\n\nTODO: reader, give details, comment.\n\n\n def read_uint_factory(instance): # use the name factory ?\n...     num_bits = instance.num_bits\n...     def read_uint(stream, n=None):\n...         if n is None:\n...             integer = 0\n...             for _ in range(num_bits):\n...                 integer = integer \n 1\n...                 if stream.read(bool):\n...                     integer += 1\n...             return integer\n...         else:\n...             integers = [read_uint(stream) for _ in range(n)]\n...             return integers\n...     return read_uint\n\n\n bitstream.register(uint, reader=read_uint_factory)\n\n\n stream = BitStream([0, 1, 2, 3, 4], uint(8))\n\n stream.read(uint(8))\n0\n\n stream.read(uint(8), 1)\n[1]\n\n stream.read(uint(8), 3)\n[2, 3, 4]", 
            "title": "Custom Readers/Writers"
        }, 
        {
            "location": "/custom/#custom-writers-and-readers", 
            "text": "import bitstream", 
            "title": "Custom Writers and Readers"
        }, 
        {
            "location": "/custom/#definition-and-registration-of-writers-and-readers", 
            "text": "Let's define a writer for the binary representation of natural numbers:   def write_integer(stream, data):\n...     if isinstance(data, list):\n...         for integer in data:\n...             write_integer(stream, integer)\n...     else:\n...         integer = int(data)\n...         if integer   0:\n...             error = \"negative integers cannot be encoded\"\n...             raise ValueError(error)\n...         bools = []\n...         while integer:\n...             bools.append(integer   1)\n...             integer = integer   1\n...         bools.reverse()\n...         stream.write(bools, bool)  We can check that this writer behaves as expected:   stream = BitStream()  write_integer(stream, 42)  stream\n101010  write_integer(stream, [1, 2, 3])  stream\n10101011011  Then, we can associate it to the type  int :   bitstream.register(int, writer=write_integer)  After this step,  BitStream  will redirect all data of type  int  to this writer:   BitStream(42)\n101010  BitStream([1, 2, 3])\n11011  If the type information is explicit, other kind of data can use this writer too:   BitStream(uint8(42), int)\n101010  BitStream(\"42\", int)\n101010  A possible implementation of the corresponding reader is given by:   def read_integer(stream, n=None):\n...     if n is not None:\n...         error = \"unsupported argument n\"\n...         raise NotImplementedError(error)\n...     else:\n...         integer = 0\n...         for _ in range(len(stream)):\n...             integer = integer   1\n...             if stream.read(bool):\n...                 integer += 1\n...     return integer  read_integer(BitStream(42))\n42  Once this reader is registered with   bitstream.register(int, reader=read_integer)  the calls to  read_integer  can be made through the  read  method of  BitStream .   BitStream(42).read(int)\n42  In all readers, the second argument of readers, named  n , \nrepresents the number of values to read from the stream. \nHere, this argument is not supported, instead any call to this reader \ninterprets the complete stream content as a single value.", 
            "title": "Definition and Registration of Writers and Readers"
        }, 
        {
            "location": "/custom/#writer-and-reader-factories", 
            "text": "We actually had a legitimate reason not to support the number of values argument \nin the binary representation reader. Indeed, when the binary representation \nis used to code sequence of integers instead of a single integer, it becomes \nambiguous: the same bitstream may represent several sequences of integers. \nFor example, we have:   BitStream(255)\n11111111  BitStream([15, 15])\n11111111  BitStream([3, 7, 3, 1])\n11111111  BitStream([3, 3, 3, 3])\n11111111  We say that this code is not  self-delimiting , as there is no way to know \nwhere is the boundary between the bits coding for different integers.   For natural numbers with known bounds, we may solve this problem by setting\na number of bits to be used for each integer. However, to do that, we\nwould have to define and register a new writer for every possible number\nof bits. Instead, we register a single but configurable writer, defined\nby a writer factory.  Let's define a type tag  uint  whose instances hold a number of bits:   class uint(object):\n...     def __init__(self, num_bits):\n...         self.num_bits = num_bits  Then, we define a factory that given a  uint  instance, \nreturns a stream writer:   def write_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def write_uint(stream, data):\n...         if isinstance(data, list):\n...             for integer in data:\n...                 write_uint(stream, integer)\n...         else:\n...             integer = int(data)\n...             if integer   0:\n...                 error = \"negative integers cannot be encoded\"\n...                 raise ValueError(error)\n...             bools = []\n...             for _ in range(num_bits):\n...                 bools.append(integer   1)\n...                 integer = integer   1\n...             bools.reverse()\n...             stream.write(bools, bool)\n...     return write_uint  Finally, we register this writer factory with  bitstream :   bitstream.register(uint, writer=write_uint_factory)  To select a writer, we use the proper instance of type tag:   BitStream(255, uint(8))\n11111111  BitStream(255, uint(16))\n0000000011111111  BitStream(42, uint(8))\n00101010  BitStream(0, uint(16))\n0000000000000000  TODO: reader, give details, comment.   def read_uint_factory(instance): # use the name factory ?\n...     num_bits = instance.num_bits\n...     def read_uint(stream, n=None):\n...         if n is None:\n...             integer = 0\n...             for _ in range(num_bits):\n...                 integer = integer   1\n...                 if stream.read(bool):\n...                     integer += 1\n...             return integer\n...         else:\n...             integers = [read_uint(stream) for _ in range(n)]\n...             return integers\n...     return read_uint  bitstream.register(uint, reader=read_uint_factory)  stream = BitStream([0, 1, 2, 3, 4], uint(8))  stream.read(uint(8))\n0  stream.read(uint(8), 1)\n[1]  stream.read(uint(8), 3)\n[2, 3, 4]", 
            "title": "Writer and Reader Factories"
        }, 
        {
            "location": "/snapshots/", 
            "text": "Snapshots\n\n\nA stream is a simple model to deal with binary data,\nbut sometimes you need more: you want to perform some lookahead without \nchanging the stream or you want to try some read/write operations \nbut go back to the initial state if they fail. \nAt this stage, you probably have copies of streams \neverywhere and the stream interface seems very cumbersome.\n\n\nTherefore, we provide snapshots, a simple solution for these\nuse cases that doesn't require copies of streams:\nyou can save the state of a stream at any \nstage in a sequence of read/write operations and restore \nany such state later if you need it.\n\n\nLookahead\n\n\nThe type of binary data can usually be identified by a specific header\ncoded in its first few bytes.\nFor example, \nWAVE\n audio can be detected with the function:\n\n\n from bitstream import BitStream, ReadError\n\n\n def is_wave(stream):\n...    try:\n...        riff = stream.read(str, 4)\n...        _ = stream.read(str, 4)\n...        wave = stream.read(str, 4)\n...        return (riff == \"RIFF\") and (wave == \"WAVE\")\n...    except ReadError:\n...        return False\n\n\n\nThe contents of an empty single-channel 44.1 kHz WAVE audio file are for example\n\n\n wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'\n\n\n\nThe function \nis_wave\n above works as expected at first\n\n\n stream = BitStream(wave)\n\n is_wave(stream)\nTrue\n\n\n\nbut another attempt gives an incorrect answer:\n\n\n is_wave(stream)\nFalse\n\n\n\nThe explanation is simple: to identify the header of a WAVE file,\nwe need to consume the first 12 bytes in the stream. \nSince this header is missing from the stream afterwards, \nthe new attempt fails.\n\n\nTo solve this issue, \nit's possible to make \nis_wave\n perform a (partial) copy of the stream \nand perform the check on the copy, leaving the initial \nstream unchanged. \nHowever in general this approach may be cumbersome;\ncopies should also be avoided when possible for performance reasons.\n\n\nBitstream also supports snapshots, \na better way to deal with lookaheads.\nWith them you can:\n\n\n\n\n\n\nsave the state of a stream at any time, \n\n\n\n\n\n\nperform arbitrary operations on it and then \n\n\n\n\n\n\nrestore its initial state.\n\n\n\n\n\n\nThe implementation of \nis_wave\n that does this is plain;\nwe just make sure that whatever happens \n(even an error in the processing) \nthe original state of the stream is restored at the end. \n\n\n def is_wave(stream):\n...     snapshot = stream.save()\n...     try:\n...         riff = stream.read(str, 4)\n...         _ = stream.read(str, 4)\n...         wave = stream.read(str, 4)\n...         return (riff == \"RIFF\") and (wave == \"WAVE\")\n...     except ReadError:\n...         return False\n...     finally:\n...         stream.restore(snapshot)\n\n\n\nThis version works as expected:\n\n\n wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'\n\n stream = BitStream(wave)\n\n copy = stream.copy()\n\n is_wave(stream)\nTrue\n\n stream == copy\nTrue\n\n is_wave(stream)\nTrue\n\n\n\nException Safety\n\n\nConsider the toy DNA reader below:\n\n\n def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     bases = []\n...     for i in range(n):\n...         base = stream.read(str, 1)\n...         if base not in DNA_bases:\n...             error = \"invalid base {0!r}\".format(base)\n...             raise ReadError(error)\n...         else:\n...             bases.append(base)\n...     return \"\".join(bases)\n\n\n\nIt reads DNA sequences represented as strings of \n\n'A'\n, \n'C'\n, \n'G'\n and \n'T'\n characters:\n\n\n dna = BitStream(\"GATA\")\n\n DNA_read(dna, 4)\n'GATA'\n\n\n\nIf there is a \n'U'\n in the sequence, this is an error since\nthe \nuracil base\n \nis only found in RNA.\n\n\n stream = BitStream(\"GAUTA\") # invalid DNA sequence\n\n\n\nThe DNA reader correctly rejects the code\n\n\n DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'\n\n\n\nbut the initial stream is partially consumed in the process:\n\n\n stream.read(str)\n'TA'\n\n\n\nThis implementation therefore only provides some basic exception safety.\nA reader that preserves the original value of the stream when an error\noccurs would provide \nstrong exception safety\n instead.\nWith snapshots, the modifications required to support this \nare plain: we simply restore the original stream whenever an\nerror occurs\n\n\n def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     snapshot = stream.save()\n...     try:\n...         bases = []\n...         for i in range(n):\n...             base = stream.read(str, 1)\n...             if base not in DNA_bases:\n...                 error = \"invalid base {0!r}\".format(base)\n...                 raise ReadError(error)\n...             else:\n...                 bases.append(base)\n...         return \"\".join(bases)\n...     except:\n...         stream.restore(snapshot)\n...         raise\n\n\n\nWith this new version, reading an invalid DNA code still \nraises an exception\n\n\n stream = BitStream(\"GAUTA\") # invalid DNA sequence\n\n DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'\n\n\n\nbut now the original stream is intact\n\n\n stream.read(str)\n'GAUTA'\n\n\n\nMultiple Snapshots\n\n\nYou can create snapshots of a stream at any stage between read/write operations.\nMultiple snapshots enable for example the implemention a hierarchy of readers \nor writers that provide strong exception safety at every level.\n\n\nHowever arbitrary sequences of save and restore are not allowed:\nwhen a given snapshot is restored, the snapshots that were created \nbetween the snapshot creation and before its restoration are forgotten.\nIn other words, saves and restores can only be applied in reverse order.\nOf course it is perfectly valid to skip some of the restores in the process:\nyou can always create additional snapshots and never use them.\n\n\nFor example, you can take two snapshots \ns0\n then \ns1\n of a stream\nbetween write operations\n\n\n stream = BitStream()\n\n s0 = stream.save()\n\n stream.write(\"A\")\n\n s1 = stream.save()\n\n stream.write(\"B\")\n\n stream == BitStream(\"AB\")\nTrue\n\n\n\nrestore \ns1\n\n\n stream.restore(s1)\n\n stream == BitStream(\"A\")\nTrue\n\n\n\nand then \ns0\n\n\n stream.restore(s0)\n\n stream == BitStream(\"\")\nTrue\n\n\n\nYou can also make the same snapshots \n\n\n stream = BitStream()\n\n s0 = stream.save()\n\n stream.write(\"A\")\n\n s1 = stream.save()\n\n stream.write(\"B\")\n\n stream == BitStream(\"AB\")\nTrue\n\n\n\nand directly restore \ns0\n\n\n stream.restore(s0)\n\n stream == BitStream(\"\")\nTrue\n\n\n\nbut then \ns1\n cannot be used anymore\n\n\n stream.restore(s1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ...", 
            "title": "Snapshots"
        }, 
        {
            "location": "/snapshots/#snapshots", 
            "text": "A stream is a simple model to deal with binary data,\nbut sometimes you need more: you want to perform some lookahead without \nchanging the stream or you want to try some read/write operations \nbut go back to the initial state if they fail. \nAt this stage, you probably have copies of streams \neverywhere and the stream interface seems very cumbersome.  Therefore, we provide snapshots, a simple solution for these\nuse cases that doesn't require copies of streams:\nyou can save the state of a stream at any \nstage in a sequence of read/write operations and restore \nany such state later if you need it.", 
            "title": "Snapshots"
        }, 
        {
            "location": "/snapshots/#lookahead", 
            "text": "The type of binary data can usually be identified by a specific header\ncoded in its first few bytes.\nFor example,  WAVE  audio can be detected with the function:   from bitstream import BitStream, ReadError  def is_wave(stream):\n...    try:\n...        riff = stream.read(str, 4)\n...        _ = stream.read(str, 4)\n...        wave = stream.read(str, 4)\n...        return (riff == \"RIFF\") and (wave == \"WAVE\")\n...    except ReadError:\n...        return False  The contents of an empty single-channel 44.1 kHz WAVE audio file are for example   wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'  The function  is_wave  above works as expected at first   stream = BitStream(wave)  is_wave(stream)\nTrue  but another attempt gives an incorrect answer:   is_wave(stream)\nFalse  The explanation is simple: to identify the header of a WAVE file,\nwe need to consume the first 12 bytes in the stream. \nSince this header is missing from the stream afterwards, \nthe new attempt fails.  To solve this issue, \nit's possible to make  is_wave  perform a (partial) copy of the stream \nand perform the check on the copy, leaving the initial \nstream unchanged. \nHowever in general this approach may be cumbersome;\ncopies should also be avoided when possible for performance reasons.  Bitstream also supports snapshots, \na better way to deal with lookaheads.\nWith them you can:    save the state of a stream at any time,     perform arbitrary operations on it and then     restore its initial state.    The implementation of  is_wave  that does this is plain;\nwe just make sure that whatever happens \n(even an error in the processing) \nthe original state of the stream is restored at the end.    def is_wave(stream):\n...     snapshot = stream.save()\n...     try:\n...         riff = stream.read(str, 4)\n...         _ = stream.read(str, 4)\n...         wave = stream.read(str, 4)\n...         return (riff == \"RIFF\") and (wave == \"WAVE\")\n...     except ReadError:\n...         return False\n...     finally:\n...         stream.restore(snapshot)  This version works as expected:   wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'  stream = BitStream(wave)  copy = stream.copy()  is_wave(stream)\nTrue  stream == copy\nTrue  is_wave(stream)\nTrue", 
            "title": "Lookahead"
        }, 
        {
            "location": "/snapshots/#exception-safety", 
            "text": "Consider the toy DNA reader below:   def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     bases = []\n...     for i in range(n):\n...         base = stream.read(str, 1)\n...         if base not in DNA_bases:\n...             error = \"invalid base {0!r}\".format(base)\n...             raise ReadError(error)\n...         else:\n...             bases.append(base)\n...     return \"\".join(bases)  It reads DNA sequences represented as strings of  'A' ,  'C' ,  'G'  and  'T'  characters:   dna = BitStream(\"GATA\")  DNA_read(dna, 4)\n'GATA'  If there is a  'U'  in the sequence, this is an error since\nthe  uracil base  \nis only found in RNA.   stream = BitStream(\"GAUTA\") # invalid DNA sequence  The DNA reader correctly rejects the code   DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'  but the initial stream is partially consumed in the process:   stream.read(str)\n'TA'  This implementation therefore only provides some basic exception safety.\nA reader that preserves the original value of the stream when an error\noccurs would provide  strong exception safety  instead.\nWith snapshots, the modifications required to support this \nare plain: we simply restore the original stream whenever an\nerror occurs   def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     snapshot = stream.save()\n...     try:\n...         bases = []\n...         for i in range(n):\n...             base = stream.read(str, 1)\n...             if base not in DNA_bases:\n...                 error = \"invalid base {0!r}\".format(base)\n...                 raise ReadError(error)\n...             else:\n...                 bases.append(base)\n...         return \"\".join(bases)\n...     except:\n...         stream.restore(snapshot)\n...         raise  With this new version, reading an invalid DNA code still \nraises an exception   stream = BitStream(\"GAUTA\") # invalid DNA sequence  DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'  but now the original stream is intact   stream.read(str)\n'GAUTA'", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/snapshots/#multiple-snapshots", 
            "text": "You can create snapshots of a stream at any stage between read/write operations.\nMultiple snapshots enable for example the implemention a hierarchy of readers \nor writers that provide strong exception safety at every level.  However arbitrary sequences of save and restore are not allowed:\nwhen a given snapshot is restored, the snapshots that were created \nbetween the snapshot creation and before its restoration are forgotten.\nIn other words, saves and restores can only be applied in reverse order.\nOf course it is perfectly valid to skip some of the restores in the process:\nyou can always create additional snapshots and never use them.  For example, you can take two snapshots  s0  then  s1  of a stream\nbetween write operations   stream = BitStream()  s0 = stream.save()  stream.write(\"A\")  s1 = stream.save()  stream.write(\"B\")  stream == BitStream(\"AB\")\nTrue  restore  s1   stream.restore(s1)  stream == BitStream(\"A\")\nTrue  and then  s0   stream.restore(s0)  stream == BitStream(\"\")\nTrue  You can also make the same snapshots    stream = BitStream()  s0 = stream.save()  stream.write(\"A\")  s1 = stream.save()  stream.write(\"B\")  stream == BitStream(\"AB\")\nTrue  and directly restore  s0   stream.restore(s0)  stream == BitStream(\"\")\nTrue  but then  s1  cannot be used anymore   stream.restore(s1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ...", 
            "title": "Multiple Snapshots"
        }, 
        {
            "location": "/contribute/", 
            "text": "Contribute\n\n\nTODO:\n\n\n\n\n\n\ncontribution process (via GitHub)\n\n\n\n\n\n\nbuild the documentation\n\n\n\n\n\n\nbuild from the sources\n\n\n\n\n\n\n\n\nBitstream targets \nPython 2.7\n, you will need to install it first.\n\n\nTODO:\n move NumPy dependency here (? Dunno ...), talk about Linux-only platform.\n\n\n\n\n\n\nInstall from source:\n the releases of Bitstream are available\n    on the \nPython Package Index (PyPi)\n. Once you have \n    downloaded and unpacked the archive, to build the Bitstream module, \n    you need \nsetuptools\n.\n    You also need to install the \nNumPy\n package, version 1.6.1 or later.\n\n\nTODO: test if numpy is automatically download if needed\n.\n\n\nThen, as root, execute\n\n\n$ python setup.py install\n\n\n\n\n\n\n\nHack with git:\n to experiment with the latest version of Bitstream, \n    clone the GitHub repository:\n\n\n$ git clone git://github.com/boisgera/bitstream.git\n\n\n\nTo actually build the module, you will need everything you need to build\nfrom source and will execute the same command. If in addition, you want\nto edit the source files, you will also need the [Cython][] compiler, \nversion 0.15.1 or later and will execute instead:\n\n\n$ python setup.py install --cython", 
            "title": "Contribute"
        }, 
        {
            "location": "/contribute/#contribute", 
            "text": "TODO:    contribution process (via GitHub)    build the documentation    build from the sources     Bitstream targets  Python 2.7 , you will need to install it first.  TODO:  move NumPy dependency here (? Dunno ...), talk about Linux-only platform.    Install from source:  the releases of Bitstream are available\n    on the  Python Package Index (PyPi) . Once you have \n    downloaded and unpacked the archive, to build the Bitstream module, \n    you need  setuptools .\n    You also need to install the  NumPy  package, version 1.6.1 or later.  TODO: test if numpy is automatically download if needed .  Then, as root, execute  $ python setup.py install    Hack with git:  to experiment with the latest version of Bitstream, \n    clone the GitHub repository:  $ git clone git://github.com/boisgera/bitstream.git  To actually build the module, you will need everything you need to build\nfrom source and will execute the same command. If in addition, you want\nto edit the source files, you will also need the [Cython][] compiler, \nversion 0.15.1 or later and will execute instead:  $ python setup.py install --cython", 
            "title": "Contribute"
        }
    ]
}