{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nBitstream is a \nPython\n library to manage binary data as bitstreams:\n\n\n from bitstream import BitStream\n\n BitStream(\"Hello World!\")\n010010000110010101101100011011000110111100100000010101110110111101110010011011000110010000100001\n\n\n\nThe main features are:\n\n\n\n\nEasy to use\n\n\nBitstreams\n are a simple abstraction.\nThey behave like communication channels: \nyou can only write data at one end of it \nand read data at the other end, in the same order.\nSo you only need to know how to create a stream, write into it\nand read it to use this library:\n\n\n stream = BitStream()\n\n stream.write(\"Hello\")\n\n stream.write(\" World!\")\n\n stream.read(str, 5)\n'Hello'\n\n stream.read(str, 7)\n' World!'\n\n\n\nThis simple way to manage binary data is good enough for a surprisingly\nlarge number of use cases. \nIt should be much easier to use than\n\nstruct\n and \n\narray\n, \nthe modules that the standard Python library provides for this task. \n\n\n\n\n\n\nWorks at the bit and byte level.\n\n\nCompact codes (for example \nHuffman codes\n)\ndo not always represent data with an entire number of bytes.\nSince bitstream supports bits and not merely bytes, such codes\nare implemented with the same API.\nFor example, the \nunary coding\n \nof a sequence natural numbers requires only a few lines:\n\n\n data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n stream = BitStream()\n\n for number in data:\n...     stream.write(number * [True] + [False])\n... \n\n stream\n0101101110111101111101111110111111101111111101111111110\n\n\n\n\n\n\n\nSupports Python \n NumPy types\n\n\nBitStream has built-in support for the common data types \nwith a standard binary layout: bools, ASCII strings, \nfixed-size integers and floating-point integers. \n\n\n stream = BitStream()\n\n stream.write(True, bool)\n\n stream.write(False, bool)\n\n from numpy import int8\n\n stream.write(-128, int8)\n\n stream.write(\"AB\", str)\n\n stream\n10100000000100000101000010\n\n stream.read(bool, 2)\n[True, False]\n\n stream.read(int8, 1)\narray([-128], dtype=int8)\n\n stream.read(str, 2)\n'AB'\n\n\n\nNumPy arrays are a convenient way to deal with sequences of homogeneous data:\n\n\n from numpy import *\n\n dt = 1.0 / 44100.0\n\n t = r_[0.0:1.0:dt]\n\n data = cos(2*pi*440.0*t)       \n\n stream = BitStream(data)\n\n\n\nRefer to the \nBuilt-in types\n section for more details.\n\n\n\n\n\n\nAdvanced features\n\n\n\n\n\n\nPerformance.\n Bitstream is a Python C-extension module that has been\n    optimized for the common use cases. Hopefully, it will be fast enough \n    for your needs! \n    Under the hood, the \nCython\n language and compiler are used to generate \n    this extension module.\n\n\n\n\n\n\nCustom types.\n\n    The list of supported types and binary \n    representation may be enlarged at will: new readers and writers \n    can be implemented and associated to specific data types.\n\n\nSee also: \nCustom types\n.\n\n\n\n\n\n\nSnapshots.\n At times, the stream abstraction is too simple,\n    for example when you need to lookahead into the stream without\n    consuming its content. Snapshots are an extension of the stream\n    model that solve this kind of issue\n    since they provide a \"time machine\" to restore a stream \n    to an earlier state.\n\n\nSee also: \nSnapshots\n.\n\n\n\n\n\n\n\n\n\n\nOpen Source\n\n\nBitstream  is distributed under a \nMIT license\n. \nThe development takes place on \nGitHub\n and \nreleases are distributed on \nPyPI\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "Bitstream is a  Python  library to manage binary data as bitstreams:   from bitstream import BitStream  BitStream(\"Hello World!\")\n010010000110010101101100011011000110111100100000010101110110111101110010011011000110010000100001  The main features are:   Easy to use  Bitstreams  are a simple abstraction.\nThey behave like communication channels: \nyou can only write data at one end of it \nand read data at the other end, in the same order.\nSo you only need to know how to create a stream, write into it\nand read it to use this library:   stream = BitStream()  stream.write(\"Hello\")  stream.write(\" World!\")  stream.read(str, 5)\n'Hello'  stream.read(str, 7)\n' World!'  This simple way to manage binary data is good enough for a surprisingly\nlarge number of use cases. \nIt should be much easier to use than struct  and  array , \nthe modules that the standard Python library provides for this task.     Works at the bit and byte level.  Compact codes (for example  Huffman codes )\ndo not always represent data with an entire number of bytes.\nSince bitstream supports bits and not merely bytes, such codes\nare implemented with the same API.\nFor example, the  unary coding  \nof a sequence natural numbers requires only a few lines:   data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  stream = BitStream()  for number in data:\n...     stream.write(number * [True] + [False])\n...   stream\n0101101110111101111101111110111111101111111101111111110    Supports Python   NumPy types  BitStream has built-in support for the common data types \nwith a standard binary layout: bools, ASCII strings, \nfixed-size integers and floating-point integers.    stream = BitStream()  stream.write(True, bool)  stream.write(False, bool)  from numpy import int8  stream.write(-128, int8)  stream.write(\"AB\", str)  stream\n10100000000100000101000010  stream.read(bool, 2)\n[True, False]  stream.read(int8, 1)\narray([-128], dtype=int8)  stream.read(str, 2)\n'AB'  NumPy arrays are a convenient way to deal with sequences of homogeneous data:   from numpy import *  dt = 1.0 / 44100.0  t = r_[0.0:1.0:dt]  data = cos(2*pi*440.0*t)         stream = BitStream(data)  Refer to the  Built-in types  section for more details.    Advanced features    Performance.  Bitstream is a Python C-extension module that has been\n    optimized for the common use cases. Hopefully, it will be fast enough \n    for your needs! \n    Under the hood, the  Cython  language and compiler are used to generate \n    this extension module.    Custom types. \n    The list of supported types and binary \n    representation may be enlarged at will: new readers and writers \n    can be implemented and associated to specific data types.  See also:  Custom types .    Snapshots.  At times, the stream abstraction is too simple,\n    for example when you need to lookahead into the stream without\n    consuming its content. Snapshots are an extension of the stream\n    model that solve this kind of issue\n    since they provide a \"time machine\" to restore a stream \n    to an earlier state.  See also:  Snapshots .      Open Source  Bitstream  is distributed under a  MIT license . \nThe development takes place on  GitHub  and \nreleases are distributed on  PyPI .", 
            "title": "Overview"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nWe provide the following examples of bitstream usage:\n\n\n\n\n\n\nSpoon\n: build a translator between Brainfuck programs and Spoon\n    programs.\n\n\n\n\n\n\nWave\n: synthesize a pure tone and generate the corresponding\n    WAVE audio file.\n\n\n\n\n\n\nBut first, as usual, let's start with\n\n\n from bitstream import BitStream\n\n\n\nSpoon\n\n\nSpoon\n is a derivative of the \nBrainfuck\n programming language.\nInstead of the 8 ASCII symbols used by Brainfuck, it relies on\nbinary sequences to represent each instruction. \n\n\nThe source of the \"Hello World!\" program in Brainfuck is\n1\n:\n\n\n hello_world = \"++++++++++[\n+++++++\n++++++++++\n+++\n+\n-]\n++.\n+.+++++++..+++.\n++.\n+++++++++++++++.\n.+++.------.--------.\n+.\n.\"\n\n\n\nThe conversion between Brainfuck and Spoon is given by the table:\n\n\n spoon = {\n...   \"+\": \"1\",\n...   \"-\": \"000\",\n...   \"\n\": \"010\",\n...   \"\n\": \"011\",\n...   \"[\": \"00100\",\n...   \"]\": \"0011\",\n...   \".\": \"001010\",\n...   \",\": \"0010110\",\n... }\n\n\n\nYou may notice that the binary codes that correspond to symbols that frequently\nappear in the \nhello_world\n program (such as \n+\n) are shorter than the others,\na nice property since it generates a compact representation of Spoon programs\n2\n.\n\n\nTo create a bitstream that contains the Spoon translation of \nhello_world\n,\nwe may for each symbol in this program find the corresponding binary code \nin the \nspoon\n table, transform it into a list of bools and append this data \nto the stream.\n\n\n stream = BitStream()\n\n for symbol in hello_world:\n...     code = spoon[symbol]\n...     code_as_bools = [bool(int(char)) for char in code]\n...     stream.write(code_as_bools)\n\n\n\nHere is the result:\n\n\n stream\n11111111110010001011111110101111111111010111010101101101101100000110101100101001010010101111111001010001010111001010010110010100110111111111111111110010100100010101110010100000000000000000000010100000000000000000000000000010100101001010010001010\n\n len(hello_world) * 8\n888\n\n len(stream)\n245\n\n\n\nWe now have of program of 245 bits instead of the 888 bits \n(111 bytes) of the original ASCII program. Not bad ...\n\n\n\n\nIt's also pretty easy to perform the opposite operation, to translate Spoon into\nBrainfuck. First, we can compute \nnoops\n, the inverse of the \nspoon\n dictionary.\n\n\n noops = {}\n\n for symbol, code in spoon.items():\n...     noops[code] = symbol\n\n n = max(len(code) for code in noops)\n\n\n\nThen we read bits one by one from the stream into a buffer and look at each \nstage if the buffer corresponds to a key in \nnoops\n, translate this code,\nempty the buffer and start again\n3\n.\n\n\n src = \"\"\n\n buffer = BitStream()\n\n while len(stream) \n 0:\n...     if len(buffer) \n n:\n...         raise ValueError(\"invalid Spoon bitstream\")\n...     else:\n...         buffer.write(stream.read(bool))\n...         try:\n...             src += noops[str(buffer)]\n...             buffer = BitStream()\n...         except KeyError:\n...             pass\n\n if len(buffer) \n 0: # should be empty by now\n...     raise ValueError(\"invalid Spoon bitstream\")\n\n\n\nWe can then check that \nsrc\n and \nhello_world\n are the same program:\n\n\n src == hello_world\nTrue\n\n\n\nWave\n\n\nWhat does it take to play a pure tone?\nThe synthesis of the data is quite easy: in the realm of digital audio,\nsounds are just numbers and NumPy is up to the task.\nThe painful, low-level part of the process is to actually generate an\naudio file in a format that your computer does understand. \nFortunately, this is where bitstream can help\n4\n.\n\n\nMost of the audio file formats that you may know (MP3, AAC, FLAC, ALAC, etc.)\nuse compression to reduce file size; unfortunately\nthis feature leads to rather complex formats. \nTherefore, we are going to output \nWAVE\n \nfiles instead, which are typically uncompressed.\n\n\nThe \nWAVE PCM soundfile format\n webpage\n5\n is a great source of information\nabout the format. We will use it to design our code; please have a look at it!\nHere is its high-level description:\n\n\n\n\nThe WAVE file format is a subset of Microsoft's RIFF specification for the \nstorage of multimedia files. \nA RIFF file starts out with a file header followed by a sequence of data \nchunks. \nA WAVE file is often just a RIFF file with a single \"WAVE\" chunk which \nconsists of two sub-chunks -- a \"fmt \" chunk specifying the data format \nand a \"data\" chunk containing the actual sample data. \n\n\n\n\nFirst, we import NumPy (and globally the integer types that we need).\n\n\n import numpy as np\n\n from numpy import uint8, uint16, uint32, int16\n\n\n\nWe use NumPy to produce 3 seconds of a pure tone with frequency 440 Hz\n(A4) at a sampling rate of 44.1 kHz \n(the audio CD standard).\n\n\n # Generate a waveform (pure tone)\n\n df = 44100\n\n dt = 1.0 / df\n\n T = 3.0\n\n t = np.r_[0.0:T:dt]\n\n f = 440.0\n\n data = np.sin(2 * np.pi * f * t)\n\n\n\nIn this description, every sample is a floating-point number that requires \n64 bits. The typical WAVE file requires 16-bit integer data instead, so we\nperform the (lossy) conversion:\n\n\n # Quantize the floating-point data\n\n ones_ = np.ones_like(data)\n\n low  = (-2**15    ) * ones_\n\n high = ( 2**15 - 1) * ones_\n\n data = np.clip(2**15 * data, low, high)\n\n data = np.round(data).astype(np.int16)\n\n\n\nSince WAVE files use a \nlittle-endian\n\nrepresentation every numeric value\nand since bitstream is \nbig-endian\n\nby default, we define a small function to\nhelp us perform the change automatically, using the \nnewbyteorder\n \nmethod of NumPy.\n\n\n # Stream endianness helper \n\n stream = BitStream()\n\n def write(datum, type=None):\n...     if type and issubclass(type, np.integer):\n...         datum = type(datum).newbyteorder()\n...     stream.write(datum, type)\n\n\n\nThe rest of the work is a straightforward translation of the \n\nspecification\n: first we write the main chunk\n\n\n # \"RIFF\" Chunk Descriptor\n\n chunk_size = 36 + 2 * len(data)  # size of the chunk after \"RIFF\"\n\n \n\n write(\"RIFF\"            )\n\n write(chunk_size, uint32)\n\n write(\"WAVE\"            )\n\n\n\nthen the format subchunk\n\n\n # \"fmt\" SubChunk\n\n subchunk1_size  = 16      # size in bytes of the subchunk after \"fmt \" \n\n audio_format    = 1       # PCM data\n\n num_channels    = 1       # mono\n\n byte_rate       = 2 * df\n\n block_align     = 2       # number of bytes for one sample (all channels)\n\n bits_per_sample = 16\n\n \n\n write(\"fmt \"                 )\n\n write(subchunk1_size , uint32)\n\n write(audio_format   , uint16)\n\n write(num_channels   , uint16)\n\n write(df             , uint32)\n\n write(byte_rate      , uint32)\n\n write(block_align    , uint16)\n\n write(bits_per_sample, uint16)\n\n\n\nand finally the data subchunk\n\n\n # \"data\" SubChunk\n\n subchunk2_size = 2 * len(data)  # size in bytes of the subchunk after \"data\"\n\n  \n\n write(\"data\"                )\n\n write(subchunk2_size, uint32)\n\n write(data          ,  int16)\n\n\n\nand that's it! \nstream\n holds the content of our WAVE file;\nall we have to do is to read it as a string that we write into an \nactual file.\n\n\n # Generate the WAVE file\n\n wave_str = stream.read(str)\n\n wave_file = open(\"output.wav\", \"w\")\n\n wave_file.write(wave_str)\n\n\n\nYou can now listen to the sound in \noutput.wav\n with your favorite music player.\n\n\nFor the sake of consistency, let's make sure that you and I have the same \ncontents:\n\n\n import hashlib\n\n m = hashlib.md5()\n\n m.update(wave_str)\n\n m.digest()\n'\\xb0\\xcf\\x0e8\\x150\\x1fV \\x86\\x9e2\\xdf\\xfb\\x1d\\xec'\n\n\n\n\n\n\n\n\n\n\n\nYou don't have to trust me on this, you may try this code online at \nhttps://copy.sh/brainfuck/\n.\n\n\n\n\n\n\nThis is not a coincidence: Spoon has been designed as \na \nHuffman code\n\nbased on the analysis of a representative collection of Brainfuck programs.\n\n\n\n\n\n\nThis approach -- without any lookahead -- is safe here because \n    this code is \nprefix-free\n.\n\n\n\n\n\n\nOf course, there is a module in the Python standard library to\n\nread and write WAV files\n.\nWe just pretend that we're in the mood to reinvent this wheel and learn\nsomething in the process.\n\n\n\n\n\n\nby \nCraig Sapp\n from the\n   \nCenter for Computer Research in Music and Acoustics\n:", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "We provide the following examples of bitstream usage:    Spoon : build a translator between Brainfuck programs and Spoon\n    programs.    Wave : synthesize a pure tone and generate the corresponding\n    WAVE audio file.    But first, as usual, let's start with   from bitstream import BitStream", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#spoon", 
            "text": "Spoon  is a derivative of the  Brainfuck  programming language.\nInstead of the 8 ASCII symbols used by Brainfuck, it relies on\nbinary sequences to represent each instruction.   The source of the \"Hello World!\" program in Brainfuck is 1 :   hello_world = \"++++++++++[ +++++++ ++++++++++ +++ + -] ++. +.+++++++..+++. ++. +++++++++++++++. .+++.------.--------. +. .\"  The conversion between Brainfuck and Spoon is given by the table:   spoon = {\n...   \"+\": \"1\",\n...   \"-\": \"000\",\n...   \" \": \"010\",\n...   \" \": \"011\",\n...   \"[\": \"00100\",\n...   \"]\": \"0011\",\n...   \".\": \"001010\",\n...   \",\": \"0010110\",\n... }  You may notice that the binary codes that correspond to symbols that frequently\nappear in the  hello_world  program (such as  + ) are shorter than the others,\na nice property since it generates a compact representation of Spoon programs 2 .  To create a bitstream that contains the Spoon translation of  hello_world ,\nwe may for each symbol in this program find the corresponding binary code \nin the  spoon  table, transform it into a list of bools and append this data \nto the stream.   stream = BitStream()  for symbol in hello_world:\n...     code = spoon[symbol]\n...     code_as_bools = [bool(int(char)) for char in code]\n...     stream.write(code_as_bools)  Here is the result:   stream\n11111111110010001011111110101111111111010111010101101101101100000110101100101001010010101111111001010001010111001010010110010100110111111111111111110010100100010101110010100000000000000000000010100000000000000000000000000010100101001010010001010  len(hello_world) * 8\n888  len(stream)\n245  We now have of program of 245 bits instead of the 888 bits \n(111 bytes) of the original ASCII program. Not bad ...   It's also pretty easy to perform the opposite operation, to translate Spoon into\nBrainfuck. First, we can compute  noops , the inverse of the  spoon  dictionary.   noops = {}  for symbol, code in spoon.items():\n...     noops[code] = symbol  n = max(len(code) for code in noops)  Then we read bits one by one from the stream into a buffer and look at each \nstage if the buffer corresponds to a key in  noops , translate this code,\nempty the buffer and start again 3 .   src = \"\"  buffer = BitStream()  while len(stream)   0:\n...     if len(buffer)   n:\n...         raise ValueError(\"invalid Spoon bitstream\")\n...     else:\n...         buffer.write(stream.read(bool))\n...         try:\n...             src += noops[str(buffer)]\n...             buffer = BitStream()\n...         except KeyError:\n...             pass  if len(buffer)   0: # should be empty by now\n...     raise ValueError(\"invalid Spoon bitstream\")  We can then check that  src  and  hello_world  are the same program:   src == hello_world\nTrue", 
            "title": "Spoon"
        }, 
        {
            "location": "/examples/#wave", 
            "text": "What does it take to play a pure tone?\nThe synthesis of the data is quite easy: in the realm of digital audio,\nsounds are just numbers and NumPy is up to the task.\nThe painful, low-level part of the process is to actually generate an\naudio file in a format that your computer does understand. \nFortunately, this is where bitstream can help 4 .  Most of the audio file formats that you may know (MP3, AAC, FLAC, ALAC, etc.)\nuse compression to reduce file size; unfortunately\nthis feature leads to rather complex formats. \nTherefore, we are going to output  WAVE  \nfiles instead, which are typically uncompressed.  The  WAVE PCM soundfile format  webpage 5  is a great source of information\nabout the format. We will use it to design our code; please have a look at it!\nHere is its high-level description:   The WAVE file format is a subset of Microsoft's RIFF specification for the \nstorage of multimedia files. \nA RIFF file starts out with a file header followed by a sequence of data \nchunks. \nA WAVE file is often just a RIFF file with a single \"WAVE\" chunk which \nconsists of two sub-chunks -- a \"fmt \" chunk specifying the data format \nand a \"data\" chunk containing the actual sample data.    First, we import NumPy (and globally the integer types that we need).   import numpy as np  from numpy import uint8, uint16, uint32, int16  We use NumPy to produce 3 seconds of a pure tone with frequency 440 Hz\n(A4) at a sampling rate of 44.1 kHz \n(the audio CD standard).   # Generate a waveform (pure tone)  df = 44100  dt = 1.0 / df  T = 3.0  t = np.r_[0.0:T:dt]  f = 440.0  data = np.sin(2 * np.pi * f * t)  In this description, every sample is a floating-point number that requires \n64 bits. The typical WAVE file requires 16-bit integer data instead, so we\nperform the (lossy) conversion:   # Quantize the floating-point data  ones_ = np.ones_like(data)  low  = (-2**15    ) * ones_  high = ( 2**15 - 1) * ones_  data = np.clip(2**15 * data, low, high)  data = np.round(data).astype(np.int16)  Since WAVE files use a  little-endian \nrepresentation every numeric value\nand since bitstream is  big-endian \nby default, we define a small function to\nhelp us perform the change automatically, using the  newbyteorder  \nmethod of NumPy.   # Stream endianness helper   stream = BitStream()  def write(datum, type=None):\n...     if type and issubclass(type, np.integer):\n...         datum = type(datum).newbyteorder()\n...     stream.write(datum, type)  The rest of the work is a straightforward translation of the  specification : first we write the main chunk   # \"RIFF\" Chunk Descriptor  chunk_size = 36 + 2 * len(data)  # size of the chunk after \"RIFF\"    write(\"RIFF\"            )  write(chunk_size, uint32)  write(\"WAVE\"            )  then the format subchunk   # \"fmt\" SubChunk  subchunk1_size  = 16      # size in bytes of the subchunk after \"fmt \"   audio_format    = 1       # PCM data  num_channels    = 1       # mono  byte_rate       = 2 * df  block_align     = 2       # number of bytes for one sample (all channels)  bits_per_sample = 16    write(\"fmt \"                 )  write(subchunk1_size , uint32)  write(audio_format   , uint16)  write(num_channels   , uint16)  write(df             , uint32)  write(byte_rate      , uint32)  write(block_align    , uint16)  write(bits_per_sample, uint16)  and finally the data subchunk   # \"data\" SubChunk  subchunk2_size = 2 * len(data)  # size in bytes of the subchunk after \"data\"     write(\"data\"                )  write(subchunk2_size, uint32)  write(data          ,  int16)  and that's it!  stream  holds the content of our WAVE file;\nall we have to do is to read it as a string that we write into an \nactual file.   # Generate the WAVE file  wave_str = stream.read(str)  wave_file = open(\"output.wav\", \"w\")  wave_file.write(wave_str)  You can now listen to the sound in  output.wav  with your favorite music player.  For the sake of consistency, let's make sure that you and I have the same \ncontents:   import hashlib  m = hashlib.md5()  m.update(wave_str)  m.digest()\n'\\xb0\\xcf\\x0e8\\x150\\x1fV \\x86\\x9e2\\xdf\\xfb\\x1d\\xec'      You don't have to trust me on this, you may try this code online at  https://copy.sh/brainfuck/ .    This is not a coincidence: Spoon has been designed as \na  Huffman code \nbased on the analysis of a representative collection of Brainfuck programs.    This approach -- without any lookahead -- is safe here because \n    this code is  prefix-free .    Of course, there is a module in the Python standard library to read and write WAV files .\nWe just pretend that we're in the mood to reinvent this wheel and learn\nsomething in the process.    by  Craig Sapp  from the\n    Center for Computer Research in Music and Acoustics :", 
            "title": "Wave"
        }, 
        {
            "location": "/installation/", 
            "text": "Bitstream supports Python 2.7 on Linux, Windows and MacOS.\n\n\nWe recommend you to install bitstream with pip. \nIf for some reason that doesn't work for you \n-- for example if you want to modify the software -- \nyou can also install bitstream from sources.\n\n\nInstall with Pip\n\n\nCheck the following prerequisites \n\n\nPip\nThe pip package installer should be available for Python 2.7\n$ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)\n\nOtherwise follow these \ninstructions\n.\nNumPy\nBitstream depends on the \nNumPy\n package; install it if necessary:\n$ pip install numpy\n\nC compiler\nYou need a compiler pip can work with. \nOn Windows, you can install the \n\nMicrosoft Visual C++ Compiler for Python 2.7\n.\nthen install bitstream:\n\n\n$ pip install bitstream\n\n\n\nInstall from Sources\n\n\nBitstream is a \nCython\n project.\nIts source files have \n.pyx\n and \n.pxd\n extensions.\n\n\nDownload the Sources\nFor example, with \ngit\n:\n$ git clone https://github.com/boisgera/bitstream\n$ cd bitstream\n\nPip Install Dependencies\nInstall the tools required for a pip install\n.\nCython\nInstall the Cython compiler\n. Typically:\n$ pip install Cython\n\nYou're now ready to install bitstream: run the command\n\n\n    $ python setup.py --cython install\n\n\n\nTroubleshooting\n\n\nWhat if pip is available but associated to Python 3?\nIf \npip\n refers to your Python 3 interpreter\n$ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)\n\nyou may still have a version of pip for Python 2.7 installed.\nIt may be named \npip2\n or \npip2.7\n; you can use it to install bitstream.\nOtherwise, refer to your Python 2.7 interpreter explicitly: \nif it is named \npython\n$ python --version\nPython 2.7.12\n\nthen install pip for Python 2.7 with\n$ python -m pip install --upgrade pip\n\nand finally install bitstream\n$ python -m pip install bitstream\n\nThe command \npython setup.py install\n doesn't work\nThis is expected:\nthis command needs C files to build bitstream,\nwhich is a Python C extension module,\nbut these files are not present in the git repository.\nThey have first to be generated by the Cython compiler\nfrom the \n.pyx\n and \n.pxd\n files with:\n$ python setup.py --cython build\n\nTo \"solve\" this issue, you can make the \n--cython\n option implicit\nwith a \nsetup.cfg\n file that contains:\n[global]\ncython = 1", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#install-with-pip", 
            "text": "Check the following prerequisites   Pip The pip package installer should be available for Python 2.7 $ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7) Otherwise follow these  instructions . NumPy Bitstream depends on the  NumPy  package; install it if necessary: $ pip install numpy C compiler You need a compiler pip can work with. \nOn Windows, you can install the  Microsoft Visual C++ Compiler for Python 2.7 . then install bitstream:  $ pip install bitstream", 
            "title": "Install with Pip"
        }, 
        {
            "location": "/installation/#install-from-sources", 
            "text": "Bitstream is a  Cython  project.\nIts source files have  .pyx  and  .pxd  extensions.  Download the Sources For example, with  git : $ git clone https://github.com/boisgera/bitstream\n$ cd bitstream Pip Install Dependencies Install the tools required for a pip install . Cython Install the Cython compiler . Typically: $ pip install Cython You're now ready to install bitstream: run the command      $ python setup.py --cython install", 
            "title": "Install from Sources"
        }, 
        {
            "location": "/installation/#troubleshooting", 
            "text": "What if pip is available but associated to Python 3? If  pip  refers to your Python 3 interpreter $ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5) you may still have a version of pip for Python 2.7 installed.\nIt may be named  pip2  or  pip2.7 ; you can use it to install bitstream.\nOtherwise, refer to your Python 2.7 interpreter explicitly: \nif it is named  python $ python --version\nPython 2.7.12 then install pip for Python 2.7 with $ python -m pip install --upgrade pip and finally install bitstream $ python -m pip install bitstream The command  python setup.py install  doesn't work This is expected:\nthis command needs C files to build bitstream,\nwhich is a Python C extension module,\nbut these files are not present in the git repository.\nThey have first to be generated by the Cython compiler\nfrom the  .pyx  and  .pxd  files with: $ python setup.py --cython build To \"solve\" this issue, you can make the  --cython  option implicit\nwith a  setup.cfg  file that contains: [global]\ncython = 1", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/types/", 
            "text": "Built-in Types\n\n\nBitstream reads and writes work out-of-the-box for many Python data types.\nIt is also tightly integrated with \nNumPy\n,\nsince this is the library of choice to deals with arrays of numeric data.\n\n\n from bitstream import BitStream\n\n from numpy import *\n\n\n\nBools\n\n\nWrite single bits to a bitstream with the arguments \nTrue\n and \nFalse\n:\n\n\n stream = BitStream()\n\n stream.write(False, bool)\n\n stream.write(True , bool)\n\n stream\n01\n\n\n\nRead them back in the same order with\n\n\n stream.read(bool)\nFalse\n\n stream.read(bool)\nTrue\n\n stream\n\nBLANKLINE\n\n\n\n\nWrite multiple bits at once with lists of bools:\n\n\n stream = BitStream()\n\n stream.write([], bool)\n\n stream\n\nBLANKLINE\n\n\n stream.write([False], bool)\n\n stream.write([True] , bool)\n\n stream\n01\n\n stream.write([False, True], bool)\n\n stream\n0101\n\n\n\nAlternatively, specify the data type \nbool\n as a a keyword argument:\n\n\n stream = BitStream()\n\n stream.write(False, type=bool)\n\n stream.write(True , type=bool)\n\n stream\n01\n\n\n\nFor single bools or lists of bools, this type information is optional:\n\n\n stream = BitStream()\n\n stream.write(False)\n\n stream.write(True)\n\n stream.write([])\n\n stream.write([False])\n\n stream.write([True])\n\n stream.write([False, True])\n\n stream\n010101\n\n\n\nTo read one boolean from a stream, do\n\n\n stream.read(bool)\nFalse\n\n stream\n10101\n\n\n\nand to read several booleans, use the second method argument\n\n\n stream.read(bool, 2)\n[True, False]\n\n stream\n101\n\n\n\nSince the booleans are returned in a list when the second argument \ndiffers from the default value (which is \nNone\n), \n\nstream.read(bool, 1)\n is not same as \nstream.read(bool)\n:\n\n\n copy = stream.copy()\n\n stream.read(bool, 1)\n[True]\n\n copy.read(bool)\nTrue\n\n\n\n\n\nNumpy \nbool_\n scalars or one-dimensional arrays can be used instead:\n\n\n bool_\n\ntype 'numpy.bool_'\n\n\n stream = BitStream()\n\n stream.write(bool_(False)  , bool)\n\n stream.write(bool_(True)   , bool)\n\n stream\n01\n\n\n stream = BitStream()\n\n empty = array([], dtype=bool)\n\n stream.write(empty, bool)\n\n stream\n\nBLANKLINE\n\n\n stream.write(array([False]), bool)\n\n stream.write(array([True]) , bool)\n\n stream.write(array([False, True]), bool)\n\n stream\n0101\n\n\n\nFor such data, the type information is also optional:\n\n\n stream = BitStream()\n\n stream.write(bool_(False))\n\n stream.write(bool_(True))\n\n stream.write(array([], dtype=bool))\n\n stream.write(array([False]))\n\n stream.write(array([True]))\n\n stream.write(array([False, True]))\n\n stream\n010101\n\n\n\nActually, many more types can be used as booleans \nwhen the type information is explicit.\nFor example, Python and Numpy numeric types are valid arguments: \nzero is considered false and nonzero numbers are considered true.\n\n\n stream = BitStream()\n\n stream.write(0.0, bool)\n\n stream.write(1.0, bool)\n\n stream.write(pi , bool)\n\n stream.write(float64(0.0), bool)\n\n stream.write(float64(1.0), bool)\n\n stream.write(float64(pi) , bool)\n\n stream\n011011\n\n\n\nStrings are also valid arguments, with a boolean value of \nTrue\n unless\nthey are empty.\nOne-dimensional lists and numpy arrays are considered holders of \nmultiple data, each of which is converted to bool.\n\n\n bool(\"\")\nFalse\n\n bool(\" \")\nTrue\n\n bool(\"A\")\nTrue\n\n bool(\"AAA\")\nTrue\n\n\n stream = BitStream()\n\n stream.write(\"\", bool)\n\n stream.write(\" \", bool)\n\n stream.write(\"A\", bool)\n\n stream.write(\"AAA\", bool)\n\n stream\n0111\n\n stream = BitStream()\n\n stream.write([\"\", \" \" , \"A\", \"AAA\"], bool)\n\n stream\n0111\n\n stream = BitStream()\n\n stream.write(array([\"\", \" \" , \"A\", \"AAA\"]), bool)\n\n stream\n0111\n\n\n\nAny other sequence (strings, tuples, lists nested in lists, etc.) \nis considered as a single datum.\n\n\n stream = BitStream()\n\n stream.write(    (), bool)\n\n stream.write(  (0,), bool)\n\n stream.write((0, 0), bool)\n\n stream\n011\n\n\n stream = BitStream()\n\n stream.write([[], [0], [0, 0]], bool)\n\n stream\n011\n\n\n\nMore generally, arbitrary custom \"bool-like\" instances, \nwhich have a \n__nonzero__\n method to handle the conversion \nto boolean, can also be used:\n\n\n class BoolLike(object):\n...     def __init__(self, value):\n...         self.value = bool(value)\n...     def __nonzero__(self):\n...         return self.value\n\n false = BoolLike(False)\n\n true = BoolLike(True)\n\n\n stream = BitStream()\n\n stream.write(false, bool)\n\n stream.write(true, bool)\n\n stream.write([false, true], bool)\n\n stream\n0101\n\n\n\nBitStreams\n\n\nA lists of bool is not the most efficient way to represent a binary stream.\nThe best type is ... an instance of \nBitStream\n of course! \n\n\nConsider the stream\n\n\n stream = BitStream()\n\n stream.write(8 * [True], bool)\n\n stream\n11111111\n\n\n\nTo read 2 bits out of \nstream\n as a bitstream, use\n\n\n stream.read(BitStream, 2)\n11\n\n\n\nSince this is a common use case, the \nBitStream\n type is assumed by default:\n\n\n new_stream = stream.read(n=2)\n\n type(new_stream) is BitStream\nTrue\n\n new_stream\n11\n\n\n\nThe simpler code below also works:\n\n\n new_stream = stream.read(2)\n\n type(new_stream) is BitStream\nTrue\n\n new_stream\n11\n\n\n\nWhen the number of items to read is also specified (\nn=None\n),\nthe read empties the stream:\n\n\n stream.read()\n11\n\n stream\n\nBLANKLINE\n\n\n\n\nStrings\n\n\nIn Python 2.7, strings are the structure of choice to represent \nbytes in memory.\nTheir type is \nstr\n (or equivalently \nbytes\n which is an alias).\nFortunately, it's straightforward to convert strings to \nbitstreams: create a stream from the string \n\"ABCD\"\n with\n\n\n stream = BitStream(\"ABCD\")\n\n\n\nTo be totally explicit, the code above is equivalent to:\n\n\n stream = BitStream()\n\n stream.write(\"ABCDE\", str)\n\n\n\nNow, the content of the stream is\n\n\n stream\n0100000101000010010000110100010001000101\n\n\n\nIt is the binary representation\nof the ASCII codes of the string characters,\nas unsigned 8-bit integers\n(see \nIntegers\n for more details):\n\n\n char_codes = [ord(char) for char in \"ABCDE\"]\n\n char_codes\n[65, 66, 67, 68, 69]\n\n stream == BitStream(char_codes, uint8)\nTrue\n\n\n\nThere is no \"single character\" type in Python: \ncharacters are represented as strings of length 1.\nTo read one or several characters from a bitstream, \nuse the \nread\n method with the \nstr\n type:\n\n\n stream.read(str, 1)\n'A'\n\n stream.read(str, 2)\n'BC'\n\n\n\nWithout an explicit number of characters, the bitstream is emptied\n\n\n stream.read(str)\n'DE'\n\n\n\nbut that works only if the bitstream contains a multiple of 8 bits.\n\n\n stream = BitStream(42 * [True])\n\n stream.read(str) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nReadError: ...\n\n\n\nTo accept up to seven trailing bits instead, use the more explicit code:\n\n\n stream = BitStream(42 * [True])\n\n n = len(stream) // 8\n\n n\n5\n\n stream.read(str, n)\n'\\xff\\xff\\xff\\xff\\xff'\n\n stream\n11\n\n\n\nIntegers\n\n\nFirst, let's clear something out: \nsince Python integers can be of arbitrary size \nand there is not a unique convenient and commonly accepted\nrepresentation for such integers\n1\n,\nyou cannot create a bitstream from Python integers by default.\n\n\n BitStream(1)\nTraceback (most recent call last):\n...\nTypeError: unsupported type 'int'.\n\n\n BitStream(2**100)\nTraceback (most recent call last):\n...\nTypeError: unsupported type 'long'.\n\n\n BitStream(\"A\").read(int)\nTraceback (most recent call last):\n...\nTypeError: unsupported type 'int'.\n\n\n\nYou need to specify somehow an integer type that determines \nwhat binary representation should be used. For example,\nto represent \n1\n as an unsigned 8bit integer:\n\n\n BitStream(1, uint8)\n00000001\n\n BitStream(uint8(1))\n00000001\n\n\n\nFor integer sequences, there are even more ways \nto specify the integer type:\n\n\n BitStream([1,2,3], uint8)\n000000010000001000000011\n\n BitStream([uint8(1), uint8(2), uint8(3)])\n000000010000001000000011\n\n BitStream(array([1, 2, 3], dtype=uint8))\n000000010000001000000011\n\n\n\nBitstream supports six integer types from numpy:\n\n\n\n\n\n\nunsigned integers: \nuint8\n, \nuint16\n, \nuint32\n\n\n\n\n\n\nsigned integers: \nint8\n, \nint16\n, \nint32\n\n\n\n\n\n\nThe representation of unsigned integers is based on their \ndecomposition as powers of 2. For example, since\n\n\n \n 13 ==  1*2**3 + 1*2**2 + 0*2**1 + 1*2**0\n True\n\n\n\nwe have\n\n\n \n BitStream(13, uint8)\n 00001101\n\n\n\nIn this scheme, only unsigned integers in the range 0-255 can be represented \nas 8bit integers. \nOut-of-bounds integers are accepted, \nbut mapped to the correct range by a modulo \n2**8\n operation. \nNumpy follows this convention\n\n\n \n 500 % 2**8\n 244\n \n uint8(500)\n 244\n\n\n\nand so does bitstream\n\n\n \n BitStream(500, uint8)\n 11110100\n \n BitStream(244, uint8)\n 11110100\n \n BitStream(500, uint8).read(uint8)\n 244\n\n\n\nThe representation of 16bit and 32bit unsigned integers \nfollows the same approach\n\n\n BitStream(2**10, uint16)\n0000010000000000\n\n BitStream(uint16(2**10))\n0000010000000000\n\n\n\nFor the readers that know about this, we use the \nbig-endian\n representation by default for multi-byte\nintegers. If you want to use the little-endian convention instead,\nNumPy provides the method \nnewbyteorder\n for this:\n\n\n BitStream(uint16(2**10).newbyteorder())\n0000000000000100\n\n\n\nFinally, for signed integers, we use the \ntwo's complement\n representation\n\n\n BitStream(0, int8)\n00000000\n\n BitStream(1, int8)\n00000001\n\n BitStream(-1, int8)\n11111111\n\n\n\nFloating-Point Numbers\n\n\nBitstream supports natively the IEE754 double-precision floating-point numbers,\nwhich have a well-defined binary representation (see e.g. \nWhat every computer scientist should know about binary arithmetic\n).\n\n\n stream = BitStream()\n\n stream.write(0.0)\n\n stream.write([1.0, 2.0, 3.0])\n\n stream.write(arange(4.0, 10.0))\n\n len(stream)\n640\n\n output = stream.read(float, 10)\n\n type(output)\n\ntype 'numpy.ndarray'\n\n\n all(output == arange(10.0))\nTrue\n\n\n\nPython built-in \nfloat\n type and NumPy \nfloat64\n types may be used interchangeably:\n\n\n BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64)\nTrue\n\n\n\nScalar, lists and arrays of floats are supported:\n\n\n BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1))\nTrue\n\n\n\nThe byte order is big endian:\n\n\n import struct\n\n PI_BE = struct.pack(\"\nd\", pi)\n\n PI_BE\n'@\\t!\\xfbTD-\\x18'\n\n BitStream(pi) == BitStream(PI_BE)\nTrue\n\n\n\nThe NumPy \nnewbyteorder\n method should be used beforeand\n(on a \nfloat64\n or an array of floats) \nto get a little-endian representation instead.\n\n\n\n\n\n\n\n\n\n\nWhy not simply use the binary decomposition of integers? \nFor example, since\n\n\n 13 == 1*2**3 + 1*2**2 + 0*2**1 + 1*2**0\nTrue\n\n\n\nyou may be tempted to not represent \n13\n as \n\n\n BitStream([True, True, False, True])\n1101\n\n\n\nBut this scheme is ambiguous if we consider \nsequences of integers: \n1101\n could represent the integer\n\n13\n but also \n[1,5]\n or \n[3,1]\n or \n[3,0,1]\n, etc.", 
            "title": "Built-in Types"
        }, 
        {
            "location": "/types/#built-in-types", 
            "text": "Bitstream reads and writes work out-of-the-box for many Python data types.\nIt is also tightly integrated with  NumPy ,\nsince this is the library of choice to deals with arrays of numeric data.   from bitstream import BitStream  from numpy import *", 
            "title": "Built-in Types"
        }, 
        {
            "location": "/types/#bools", 
            "text": "Write single bits to a bitstream with the arguments  True  and  False :   stream = BitStream()  stream.write(False, bool)  stream.write(True , bool)  stream\n01  Read them back in the same order with   stream.read(bool)\nFalse  stream.read(bool)\nTrue  stream BLANKLINE   Write multiple bits at once with lists of bools:   stream = BitStream()  stream.write([], bool)  stream BLANKLINE   stream.write([False], bool)  stream.write([True] , bool)  stream\n01  stream.write([False, True], bool)  stream\n0101  Alternatively, specify the data type  bool  as a a keyword argument:   stream = BitStream()  stream.write(False, type=bool)  stream.write(True , type=bool)  stream\n01  For single bools or lists of bools, this type information is optional:   stream = BitStream()  stream.write(False)  stream.write(True)  stream.write([])  stream.write([False])  stream.write([True])  stream.write([False, True])  stream\n010101  To read one boolean from a stream, do   stream.read(bool)\nFalse  stream\n10101  and to read several booleans, use the second method argument   stream.read(bool, 2)\n[True, False]  stream\n101  Since the booleans are returned in a list when the second argument \ndiffers from the default value (which is  None ),  stream.read(bool, 1)  is not same as  stream.read(bool) :   copy = stream.copy()  stream.read(bool, 1)\n[True]  copy.read(bool)\nTrue   Numpy  bool_  scalars or one-dimensional arrays can be used instead:   bool_ type 'numpy.bool_'   stream = BitStream()  stream.write(bool_(False)  , bool)  stream.write(bool_(True)   , bool)  stream\n01  stream = BitStream()  empty = array([], dtype=bool)  stream.write(empty, bool)  stream BLANKLINE   stream.write(array([False]), bool)  stream.write(array([True]) , bool)  stream.write(array([False, True]), bool)  stream\n0101  For such data, the type information is also optional:   stream = BitStream()  stream.write(bool_(False))  stream.write(bool_(True))  stream.write(array([], dtype=bool))  stream.write(array([False]))  stream.write(array([True]))  stream.write(array([False, True]))  stream\n010101  Actually, many more types can be used as booleans \nwhen the type information is explicit.\nFor example, Python and Numpy numeric types are valid arguments: \nzero is considered false and nonzero numbers are considered true.   stream = BitStream()  stream.write(0.0, bool)  stream.write(1.0, bool)  stream.write(pi , bool)  stream.write(float64(0.0), bool)  stream.write(float64(1.0), bool)  stream.write(float64(pi) , bool)  stream\n011011  Strings are also valid arguments, with a boolean value of  True  unless\nthey are empty.\nOne-dimensional lists and numpy arrays are considered holders of \nmultiple data, each of which is converted to bool.   bool(\"\")\nFalse  bool(\" \")\nTrue  bool(\"A\")\nTrue  bool(\"AAA\")\nTrue  stream = BitStream()  stream.write(\"\", bool)  stream.write(\" \", bool)  stream.write(\"A\", bool)  stream.write(\"AAA\", bool)  stream\n0111  stream = BitStream()  stream.write([\"\", \" \" , \"A\", \"AAA\"], bool)  stream\n0111  stream = BitStream()  stream.write(array([\"\", \" \" , \"A\", \"AAA\"]), bool)  stream\n0111  Any other sequence (strings, tuples, lists nested in lists, etc.) \nis considered as a single datum.   stream = BitStream()  stream.write(    (), bool)  stream.write(  (0,), bool)  stream.write((0, 0), bool)  stream\n011  stream = BitStream()  stream.write([[], [0], [0, 0]], bool)  stream\n011  More generally, arbitrary custom \"bool-like\" instances, \nwhich have a  __nonzero__  method to handle the conversion \nto boolean, can also be used:   class BoolLike(object):\n...     def __init__(self, value):\n...         self.value = bool(value)\n...     def __nonzero__(self):\n...         return self.value  false = BoolLike(False)  true = BoolLike(True)  stream = BitStream()  stream.write(false, bool)  stream.write(true, bool)  stream.write([false, true], bool)  stream\n0101", 
            "title": "Bools"
        }, 
        {
            "location": "/types/#bitstreams", 
            "text": "A lists of bool is not the most efficient way to represent a binary stream.\nThe best type is ... an instance of  BitStream  of course!   Consider the stream   stream = BitStream()  stream.write(8 * [True], bool)  stream\n11111111  To read 2 bits out of  stream  as a bitstream, use   stream.read(BitStream, 2)\n11  Since this is a common use case, the  BitStream  type is assumed by default:   new_stream = stream.read(n=2)  type(new_stream) is BitStream\nTrue  new_stream\n11  The simpler code below also works:   new_stream = stream.read(2)  type(new_stream) is BitStream\nTrue  new_stream\n11  When the number of items to read is also specified ( n=None ),\nthe read empties the stream:   stream.read()\n11  stream BLANKLINE", 
            "title": "BitStreams"
        }, 
        {
            "location": "/types/#strings", 
            "text": "In Python 2.7, strings are the structure of choice to represent \nbytes in memory.\nTheir type is  str  (or equivalently  bytes  which is an alias).\nFortunately, it's straightforward to convert strings to \nbitstreams: create a stream from the string  \"ABCD\"  with   stream = BitStream(\"ABCD\")  To be totally explicit, the code above is equivalent to:   stream = BitStream()  stream.write(\"ABCDE\", str)  Now, the content of the stream is   stream\n0100000101000010010000110100010001000101  It is the binary representation\nof the ASCII codes of the string characters,\nas unsigned 8-bit integers\n(see  Integers  for more details):   char_codes = [ord(char) for char in \"ABCDE\"]  char_codes\n[65, 66, 67, 68, 69]  stream == BitStream(char_codes, uint8)\nTrue  There is no \"single character\" type in Python: \ncharacters are represented as strings of length 1.\nTo read one or several characters from a bitstream, \nuse the  read  method with the  str  type:   stream.read(str, 1)\n'A'  stream.read(str, 2)\n'BC'  Without an explicit number of characters, the bitstream is emptied   stream.read(str)\n'DE'  but that works only if the bitstream contains a multiple of 8 bits.   stream = BitStream(42 * [True])  stream.read(str) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nReadError: ...  To accept up to seven trailing bits instead, use the more explicit code:   stream = BitStream(42 * [True])  n = len(stream) // 8  n\n5  stream.read(str, n)\n'\\xff\\xff\\xff\\xff\\xff'  stream\n11", 
            "title": "Strings"
        }, 
        {
            "location": "/types/#integers", 
            "text": "First, let's clear something out: \nsince Python integers can be of arbitrary size \nand there is not a unique convenient and commonly accepted\nrepresentation for such integers 1 ,\nyou cannot create a bitstream from Python integers by default.   BitStream(1)\nTraceback (most recent call last):\n...\nTypeError: unsupported type 'int'.  BitStream(2**100)\nTraceback (most recent call last):\n...\nTypeError: unsupported type 'long'.  BitStream(\"A\").read(int)\nTraceback (most recent call last):\n...\nTypeError: unsupported type 'int'.  You need to specify somehow an integer type that determines \nwhat binary representation should be used. For example,\nto represent  1  as an unsigned 8bit integer:   BitStream(1, uint8)\n00000001  BitStream(uint8(1))\n00000001  For integer sequences, there are even more ways \nto specify the integer type:   BitStream([1,2,3], uint8)\n000000010000001000000011  BitStream([uint8(1), uint8(2), uint8(3)])\n000000010000001000000011  BitStream(array([1, 2, 3], dtype=uint8))\n000000010000001000000011  Bitstream supports six integer types from numpy:    unsigned integers:  uint8 ,  uint16 ,  uint32    signed integers:  int8 ,  int16 ,  int32    The representation of unsigned integers is based on their \ndecomposition as powers of 2. For example, since     13 ==  1*2**3 + 1*2**2 + 0*2**1 + 1*2**0\n True  we have     BitStream(13, uint8)\n 00001101  In this scheme, only unsigned integers in the range 0-255 can be represented \nas 8bit integers. \nOut-of-bounds integers are accepted, \nbut mapped to the correct range by a modulo  2**8  operation. \nNumpy follows this convention     500 % 2**8\n 244\n   uint8(500)\n 244  and so does bitstream     BitStream(500, uint8)\n 11110100\n   BitStream(244, uint8)\n 11110100\n   BitStream(500, uint8).read(uint8)\n 244  The representation of 16bit and 32bit unsigned integers \nfollows the same approach   BitStream(2**10, uint16)\n0000010000000000  BitStream(uint16(2**10))\n0000010000000000  For the readers that know about this, we use the  big-endian  representation by default for multi-byte\nintegers. If you want to use the little-endian convention instead,\nNumPy provides the method  newbyteorder  for this:   BitStream(uint16(2**10).newbyteorder())\n0000000000000100  Finally, for signed integers, we use the  two's complement  representation   BitStream(0, int8)\n00000000  BitStream(1, int8)\n00000001  BitStream(-1, int8)\n11111111", 
            "title": "Integers"
        }, 
        {
            "location": "/types/#floating-point-numbers", 
            "text": "Bitstream supports natively the IEE754 double-precision floating-point numbers,\nwhich have a well-defined binary representation (see e.g.  What every computer scientist should know about binary arithmetic ).   stream = BitStream()  stream.write(0.0)  stream.write([1.0, 2.0, 3.0])  stream.write(arange(4.0, 10.0))  len(stream)\n640  output = stream.read(float, 10)  type(output) type 'numpy.ndarray'   all(output == arange(10.0))\nTrue  Python built-in  float  type and NumPy  float64  types may be used interchangeably:   BitStream(1.0) == BitStream(1.0, float) == BitStream(1.0, float64)\nTrue  Scalar, lists and arrays of floats are supported:   BitStream(1.0) == BitStream([1.0]) == BitStream(ones(1))\nTrue  The byte order is big endian:   import struct  PI_BE = struct.pack(\" d\", pi)  PI_BE\n'@\\t!\\xfbTD-\\x18'  BitStream(pi) == BitStream(PI_BE)\nTrue  The NumPy  newbyteorder  method should be used beforeand\n(on a  float64  or an array of floats) \nto get a little-endian representation instead.      Why not simply use the binary decomposition of integers? \nFor example, since   13 == 1*2**3 + 1*2**2 + 0*2**1 + 1*2**0\nTrue  you may be tempted to not represent  13  as    BitStream([True, True, False, True])\n1101  But this scheme is ambiguous if we consider \nsequences of integers:  1101  could represent the integer 13  but also  [1,5]  or  [3,1]  or  [3,0,1] , etc.", 
            "title": "Floating-Point Numbers"
        }, 
        {
            "location": "/custom/", 
            "text": "Custom Types\n\n\nThis section explains how to deal with a data type or a binary coding \nthat bitstream does not support natively: how to define bitstream \nwriter and reader functions and register them so that your custom\ntypes behave like native ones.\n\n\n import bitstream\n\n from bitstream import BitStream\n\n\n\nWe use the example of representation of unsigned integers \nas binary numbers;\nout of the box, bitstream only supports unsigned integers of fixed size \n(refer to \nBuilt-in Types / Integers\n for details).\n\n\nDefinition\n\n\nFor every type of data that we want bitstream to support, \nwe need to specify at least one writer function that\nencodes the data as a bitstream and one reader function\nthat decodes data out of bitstreams.\n\n\nThe signature of writers is\n\n\ndef writer(stream, data)\n\n\n\nwhere\n\n\n\n\n\n\nstream\n is a \nBitStream\n instance,\n\n\n\n\n\n\nthe type of \ndata\n is writer-dependent.\n\n\n\n\n\n\nA writer is totally free to specify what is a valid \ndata\n,\nbut it is sensible to accept:\n\n\n\n\n\n\ninstances of a reference data type (or some of these instances),\n\n\n\n\n\n\ndata that can be safely converted to the reference data type,\n\n\n\n\n\n\nsequences (lists, arrays, etc.) of the reference type (or assimilated).\n\n\n\n\n\n\nA writer should raise an exception (\nValueError\n or \nTypeError\n) \nwhen the data is invalid.\n\n\n\n\nTo write unsigned integers as binary numbers for example,\nwe can consider as valid anything any non-negative integer-like\ndata (defined as anything that the constructor \nint\n accepts) \nas well as lists of such data.\n\n\n def write_uint(stream, data):\n...     if isinstance(data, list):\n...         for integer in data:\n...             write_uint(stream, integer)\n...     else:\n...         integer = int(data)\n...         if integer \n 0:\n...             error = \"negative integers cannot be encoded\"\n...             raise ValueError(error)\n...         bools = []\n...         while integer:\n...             bools.append(integer \n 1)\n...             integer = integer \n 1\n...         bools.reverse()\n...         stream.write(bools, bool)\n\n\n\nThis writer behaves as expected:\n\n\n stream = BitStream()\n\n write_uint(stream, 42)\n\n stream\n101010\n\n write_uint(stream, [1, 2, 3])\n\n stream\n10101011011\n\n write_uint(stream, -1)\nTraceback (most recent call last):\n...\nValueError: negative integers cannot be encoded\n\n write_uint(stream, {})\nTraceback (most recent call last):\n...\nTypeError: int() argument must be a string or a number, not 'dict'\n\n\n\n\n\nThe signature of readers is:\n\n\ndef reader(stream, n=None)\n\n\n\nwhere\n\n\n\n\n\n\nstream\n is a \nBitStream\n instance,\n\n\n\n\n\n\nn\n is a non-negative integer (or \nNone\n).\n\n\n\n\n\n\nThe call \nread(stream, n)\n should read \nn\n data items \nout of \nstream\n when \nn\n is an integer. \nHowever, bitstream does not require a specific type of container \n(list, array, string, etc.), the choice is all yours;\nfor consistency however, you should pick a type of container\nthat your writer supports.\n\n\nThe semantics of call \nread(stream)\n (when \nn=None\n) is up to you; \nfor most of built-in types, it returns a single (unboxed) datum of\nthe stream but there are sometimes good reasons to decide otherwise\n(see for example \nstrings\n).\nThe support for this default case is not mandatory.\n\n\nActually, readers may support only a subset of the possible values of \nn\n;\nfor example they may allow only \nn=1\n and \nn=None\n.\nIf a reader is called with an invalid value of \nn\n,\na \nValueError\n or \nTypeError\n exception should be raised. \nIf instead the \nread\n fails because there is not enough \ndata in the stream or more generally if the binary data\ncannot be decoded, a \nReadError\n (from \nbitstream\n) should \nbe raised.\n\n\n\n\nWhen we represent unsigned integers as binary numbers,\nwhile we can write multiple integers in the same stream,\nwe cannot read unambiguously multiple integers from the \nstream: the code is not \nself-delimiting\n. \nFor example \n110\n can be split as \n1\n then \n10\n\nand code for the integers \n1\n and \n2\n but also \nas \n11\n and \n0\n which represent the integers \n3\n and \n0\n.\n\n\nThus, we design a reader that reads the whole stream as a single \ninteger: we support only the cases \nn=1\n \nand for convenience the default \nn=None\n with the same result.\n\n\nA possible implementation of this reader is:\n\n\n def read_uint(stream, n=None):\n...     if n is not None and not n == 1:\n...         error = \"unsupported argument n = {0!r}\".format(n)\n...         raise ValueError(error)\n...     else:\n...         integer = 0\n...         for _ in range(len(stream)):\n...             integer = integer \n 1\n...             if stream.read(bool):\n...                 integer += 1\n...     return integer\n\n\n\nIt behaves as expected:\n\n\n stream = BitStream()\n\n write_uint(stream, 42)\n\n read_uint(stream)\n42\n\n write_uint(stream, [1, 2, 3]) \n\n read_uint(stream)\n27\n\n len(stream)\n0\n\n write_uint(stream, 42)\n\n read_uint(stream, 1)\n42\n\n write_uint(stream, 42)\n\n read_uint(stream, 2)\nTraceback (most recent call last):\n...\nValueError: unsupported argument n = 2\n\n\n\nRegistration\n\n\nTo fully integrate unsigned integers into bitstream, \nyou need to associate a unique type identifier to \nthe reader and/or writer, \nThis type identifier is usually a type;\na user-defined type with an empty \ndefinition will do:\n\n\n class uint(object):\n...     pass\n\n\n\nOnce the type \nuint\n has been associated to the unsigned integer writer\n\n\n bitstream.register(uint, writer=write_uint)\n\n\n\nwe can use the \nwrite\n method of \nBitStream\n to encode unsigned integers\n\n\n stream = BitStream()\n\n stream.write(42, uint)\n\n stream\n101010\n\n\n stream = BitStream()\n\n stream.write([2, 2, 2], uint)\n\n stream\n101010\n\n\n\nand also the shorter former using the \nBitStream\n constructor\n\n\n BitStream(42, uint)\n101010\n\n BitStream([2, 2, 2], uint)\n101010\n\n\n\nOnce the reader is registered\n\n\n bitstream.register(uint, reader=read_uint)\n\n\n\nwe can also use the \nread\n method of \nBitStream\n:\n\n\n BitStream(42, uint).read(uint)\n42\n\n\n\nHere, the \nuint\n type was merely an identifier for our reader and writer,\nbut \"real\" types can be used too. If you write some data whose type is\nthe type identifier of a writer, you don't need to specify explicitly the\ntype identifier in writes.\n\n\nFor example, if we also associate our writer with Python integers:\n\n\n bitstream.register(int, writer=write_uint)\n\n bitstream.register(long, writer=write_uint)\n\n\n\nthen every Python integer will be automatically encoded with \nthe \nwrite_uint\n writer\n\n\n BitStream(42)\n101010\n\n BitStream([2, 2, 2])\n101010\n\n\n\nFactories\n\n\nThe coding of arbitrary unsigned integers as binary numbers \ndoesn't allow us to represent unambiguously multiple numbers in a stream. However, if there is a known bound on the integers we use, we can\nassign a sufficient numbers of bits to each integer, pad the\nbinary numbers with enough zeros of the left to use the same\nnumber of bits and this code is self-delimiting.\n\n\nHowever, to do that, we would have to define and register a new writer \nfor every possible number of bits. \nInstead, we may register a single but configurable writer, defined\nby a writer factory.\n\n\nLet's define a type identifier factory \nuint\n whose instances \nhold a number of bits:\n\n\n class uint(object):\n...     def __init__(self, num_bits):\n...         self.num_bits = num_bits\n\n\n\nThen, we define a writer factory: given an instance of \nuint\n, \nit returns a stream writer:\n\n\n def write_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def write_uint(stream, data):\n...         if isinstance(data, list):\n...             for integer in data:\n...                 write_uint(stream, integer)\n...         else:\n...             integer = int(data)\n...             if integer \n 0:\n...                 error = \"negative integers cannot be encoded\"\n...                 raise ValueError(error)\n...             bools = []\n...             for _ in range(num_bits):\n...                 bools.append(integer \n 1)\n...                 integer = integer \n 1\n...             bools.reverse()\n...             stream.write(bools, bool)\n...     return write_uint\n\n\n\nFinally, we register this writer factory with \nbitstream\n:\n\n\n bitstream.register(uint, writer=write_uint_factory)\n\n\n\nTo select a writer, we use the appropriate type identifier:\n\n\n BitStream(255, uint(8))\n11111111\n\n BitStream(255, uint(16))\n0000000011111111\n\n BitStream(42, uint(8))\n00101010\n\n BitStream(0, uint(16))\n0000000000000000\n\n\n\nThe definition of a reader factory is similar:\n\n\n def read_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def read_uint(stream, n=None):\n...         if n is None:\n...             integer = 0\n...             for _ in range(num_bits):\n...                 integer = integer \n 1\n...                 if stream.read(bool):\n...                     integer += 1\n...             return integer\n...         else:\n...             integers = [read_uint(stream) for _ in range(n)]\n...             return integers\n...     return read_uint\n\n\n\nOnce the reader factory is registered\n\n\n bitstream.register(uint, reader=read_uint_factory)\n\n\n\nwe can use the family of type identifiers in reads too:\n\n\n stream = BitStream([0, 1, 2, 3, 4], uint(8))\n\n stream.read(uint(8))\n0\n\n stream.read(uint(8), 1)\n[1]\n\n stream.read(uint(8), 3)\n[2, 3, 4]", 
            "title": "Custom Types"
        }, 
        {
            "location": "/custom/#custom-types", 
            "text": "This section explains how to deal with a data type or a binary coding \nthat bitstream does not support natively: how to define bitstream \nwriter and reader functions and register them so that your custom\ntypes behave like native ones.   import bitstream  from bitstream import BitStream  We use the example of representation of unsigned integers \nas binary numbers;\nout of the box, bitstream only supports unsigned integers of fixed size \n(refer to  Built-in Types / Integers  for details).", 
            "title": "Custom Types"
        }, 
        {
            "location": "/custom/#definition", 
            "text": "For every type of data that we want bitstream to support, \nwe need to specify at least one writer function that\nencodes the data as a bitstream and one reader function\nthat decodes data out of bitstreams.  The signature of writers is  def writer(stream, data)  where    stream  is a  BitStream  instance,    the type of  data  is writer-dependent.    A writer is totally free to specify what is a valid  data ,\nbut it is sensible to accept:    instances of a reference data type (or some of these instances),    data that can be safely converted to the reference data type,    sequences (lists, arrays, etc.) of the reference type (or assimilated).    A writer should raise an exception ( ValueError  or  TypeError ) \nwhen the data is invalid.   To write unsigned integers as binary numbers for example,\nwe can consider as valid anything any non-negative integer-like\ndata (defined as anything that the constructor  int  accepts) \nas well as lists of such data.   def write_uint(stream, data):\n...     if isinstance(data, list):\n...         for integer in data:\n...             write_uint(stream, integer)\n...     else:\n...         integer = int(data)\n...         if integer   0:\n...             error = \"negative integers cannot be encoded\"\n...             raise ValueError(error)\n...         bools = []\n...         while integer:\n...             bools.append(integer   1)\n...             integer = integer   1\n...         bools.reverse()\n...         stream.write(bools, bool)  This writer behaves as expected:   stream = BitStream()  write_uint(stream, 42)  stream\n101010  write_uint(stream, [1, 2, 3])  stream\n10101011011  write_uint(stream, -1)\nTraceback (most recent call last):\n...\nValueError: negative integers cannot be encoded  write_uint(stream, {})\nTraceback (most recent call last):\n...\nTypeError: int() argument must be a string or a number, not 'dict'   The signature of readers is:  def reader(stream, n=None)  where    stream  is a  BitStream  instance,    n  is a non-negative integer (or  None ).    The call  read(stream, n)  should read  n  data items \nout of  stream  when  n  is an integer. \nHowever, bitstream does not require a specific type of container \n(list, array, string, etc.), the choice is all yours;\nfor consistency however, you should pick a type of container\nthat your writer supports.  The semantics of call  read(stream)  (when  n=None ) is up to you; \nfor most of built-in types, it returns a single (unboxed) datum of\nthe stream but there are sometimes good reasons to decide otherwise\n(see for example  strings ).\nThe support for this default case is not mandatory.  Actually, readers may support only a subset of the possible values of  n ;\nfor example they may allow only  n=1  and  n=None .\nIf a reader is called with an invalid value of  n ,\na  ValueError  or  TypeError  exception should be raised. \nIf instead the  read  fails because there is not enough \ndata in the stream or more generally if the binary data\ncannot be decoded, a  ReadError  (from  bitstream ) should \nbe raised.   When we represent unsigned integers as binary numbers,\nwhile we can write multiple integers in the same stream,\nwe cannot read unambiguously multiple integers from the \nstream: the code is not  self-delimiting . \nFor example  110  can be split as  1  then  10 \nand code for the integers  1  and  2  but also \nas  11  and  0  which represent the integers  3  and  0 .  Thus, we design a reader that reads the whole stream as a single \ninteger: we support only the cases  n=1  \nand for convenience the default  n=None  with the same result.  A possible implementation of this reader is:   def read_uint(stream, n=None):\n...     if n is not None and not n == 1:\n...         error = \"unsupported argument n = {0!r}\".format(n)\n...         raise ValueError(error)\n...     else:\n...         integer = 0\n...         for _ in range(len(stream)):\n...             integer = integer   1\n...             if stream.read(bool):\n...                 integer += 1\n...     return integer  It behaves as expected:   stream = BitStream()  write_uint(stream, 42)  read_uint(stream)\n42  write_uint(stream, [1, 2, 3])   read_uint(stream)\n27  len(stream)\n0  write_uint(stream, 42)  read_uint(stream, 1)\n42  write_uint(stream, 42)  read_uint(stream, 2)\nTraceback (most recent call last):\n...\nValueError: unsupported argument n = 2", 
            "title": "Definition"
        }, 
        {
            "location": "/custom/#registration", 
            "text": "To fully integrate unsigned integers into bitstream, \nyou need to associate a unique type identifier to \nthe reader and/or writer, \nThis type identifier is usually a type;\na user-defined type with an empty \ndefinition will do:   class uint(object):\n...     pass  Once the type  uint  has been associated to the unsigned integer writer   bitstream.register(uint, writer=write_uint)  we can use the  write  method of  BitStream  to encode unsigned integers   stream = BitStream()  stream.write(42, uint)  stream\n101010  stream = BitStream()  stream.write([2, 2, 2], uint)  stream\n101010  and also the shorter former using the  BitStream  constructor   BitStream(42, uint)\n101010  BitStream([2, 2, 2], uint)\n101010  Once the reader is registered   bitstream.register(uint, reader=read_uint)  we can also use the  read  method of  BitStream :   BitStream(42, uint).read(uint)\n42  Here, the  uint  type was merely an identifier for our reader and writer,\nbut \"real\" types can be used too. If you write some data whose type is\nthe type identifier of a writer, you don't need to specify explicitly the\ntype identifier in writes.  For example, if we also associate our writer with Python integers:   bitstream.register(int, writer=write_uint)  bitstream.register(long, writer=write_uint)  then every Python integer will be automatically encoded with \nthe  write_uint  writer   BitStream(42)\n101010  BitStream([2, 2, 2])\n101010", 
            "title": "Registration"
        }, 
        {
            "location": "/custom/#factories", 
            "text": "The coding of arbitrary unsigned integers as binary numbers \ndoesn't allow us to represent unambiguously multiple numbers in a stream. However, if there is a known bound on the integers we use, we can\nassign a sufficient numbers of bits to each integer, pad the\nbinary numbers with enough zeros of the left to use the same\nnumber of bits and this code is self-delimiting.  However, to do that, we would have to define and register a new writer \nfor every possible number of bits. \nInstead, we may register a single but configurable writer, defined\nby a writer factory.  Let's define a type identifier factory  uint  whose instances \nhold a number of bits:   class uint(object):\n...     def __init__(self, num_bits):\n...         self.num_bits = num_bits  Then, we define a writer factory: given an instance of  uint , \nit returns a stream writer:   def write_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def write_uint(stream, data):\n...         if isinstance(data, list):\n...             for integer in data:\n...                 write_uint(stream, integer)\n...         else:\n...             integer = int(data)\n...             if integer   0:\n...                 error = \"negative integers cannot be encoded\"\n...                 raise ValueError(error)\n...             bools = []\n...             for _ in range(num_bits):\n...                 bools.append(integer   1)\n...                 integer = integer   1\n...             bools.reverse()\n...             stream.write(bools, bool)\n...     return write_uint  Finally, we register this writer factory with  bitstream :   bitstream.register(uint, writer=write_uint_factory)  To select a writer, we use the appropriate type identifier:   BitStream(255, uint(8))\n11111111  BitStream(255, uint(16))\n0000000011111111  BitStream(42, uint(8))\n00101010  BitStream(0, uint(16))\n0000000000000000  The definition of a reader factory is similar:   def read_uint_factory(instance):\n...     num_bits = instance.num_bits\n...     def read_uint(stream, n=None):\n...         if n is None:\n...             integer = 0\n...             for _ in range(num_bits):\n...                 integer = integer   1\n...                 if stream.read(bool):\n...                     integer += 1\n...             return integer\n...         else:\n...             integers = [read_uint(stream) for _ in range(n)]\n...             return integers\n...     return read_uint  Once the reader factory is registered   bitstream.register(uint, reader=read_uint_factory)  we can use the family of type identifiers in reads too:   stream = BitStream([0, 1, 2, 3, 4], uint(8))  stream.read(uint(8))\n0  stream.read(uint(8), 1)\n[1]  stream.read(uint(8), 3)\n[2, 3, 4]", 
            "title": "Factories"
        }, 
        {
            "location": "/snapshots/", 
            "text": "Snapshots\n\n\nA stream is a simple model to deal with binary data,\nbut sometimes you need more: you want to perform some lookahead without \nchanging the stream or you want to try some read/write operations \nbut go back to the initial state if they fail. \nAt this stage, you probably have copies of streams \neverywhere and the stream interface seems very cumbersome.\n\n\nTherefore, we provide snapshots, a simple solution for these\nuse cases that doesn't require copies of streams:\nyou can save the state of a stream at any \nstage in a sequence of read/write operations and restore \nany such state later if you need it.\n\n\nLookahead\n\n\nThe type of binary data can usually be identified by a specific header\ncoded in its first few bytes.\nFor example, \nWAVE\n audio can be detected with the function:\n\n\n from bitstream import BitStream, ReadError\n\n\n def is_wave(stream):\n...    try:\n...        riff = stream.read(str, 4)\n...        _ = stream.read(str, 4)\n...        wave = stream.read(str, 4)\n...        return (riff == \"RIFF\") and (wave == \"WAVE\")\n...    except ReadError:\n...        return False\n\n\n\nThe contents of an empty single-channel 44.1 kHz WAVE audio file are for example\n\n\n wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'\n\n\n\nThe function \nis_wave\n above works as expected at first\n\n\n stream = BitStream(wave)\n\n is_wave(stream)\nTrue\n\n\n\nbut another attempt gives an incorrect answer:\n\n\n is_wave(stream)\nFalse\n\n\n\nThe explanation is simple: to identify the header of a WAVE file,\nwe need to consume the first 12 bytes in the stream. \nSince this header is missing from the stream afterwards, \nthe new attempt fails.\n\n\nTo solve this issue, \nit's possible to make \nis_wave\n perform a (partial) copy of the stream \nand perform the check on the copy, leaving the initial \nstream unchanged. \nHowever in general this approach may be cumbersome;\ncopies should also be avoided when possible for performance reasons.\n\n\nBitstream also supports snapshots, \na better way to deal with lookaheads.\nWith them you can:\n\n\n\n\n\n\nsave the state of a stream at any time, \n\n\n\n\n\n\nperform arbitrary operations on it and then \n\n\n\n\n\n\nrestore its initial state.\n\n\n\n\n\n\nThe implementation of \nis_wave\n that does this is plain;\nwe just make sure that whatever happens \n(even an error in the processing) \nthe original state of the stream is restored at the end. \n\n\n def is_wave(stream):\n...     snapshot = stream.save()\n...     try:\n...         riff = stream.read(str, 4)\n...         _ = stream.read(str, 4)\n...         wave = stream.read(str, 4)\n...         return (riff == \"RIFF\") and (wave == \"WAVE\")\n...     except ReadError:\n...         return False\n...     finally:\n...         stream.restore(snapshot)\n\n\n\nThis version works as expected:\n\n\n wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'\n\n stream = BitStream(wave)\n\n copy = stream.copy()\n\n is_wave(stream)\nTrue\n\n stream == copy\nTrue\n\n is_wave(stream)\nTrue\n\n\n\nException Safety\n\n\nConsider the toy DNA reader below:\n\n\n def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     bases = []\n...     for i in range(n):\n...         base = stream.read(str, 1)\n...         if base not in DNA_bases:\n...             error = \"invalid base {0!r}\".format(base)\n...             raise ReadError(error)\n...         else:\n...             bases.append(base)\n...     return \"\".join(bases)\n\n\n\nIt reads DNA sequences represented as strings of \n\n'A'\n, \n'C'\n, \n'G'\n and \n'T'\n characters:\n\n\n dna = BitStream(\"GATA\")\n\n DNA_read(dna, 4)\n'GATA'\n\n\n\nIf there is a \n'U'\n in the sequence, this is an error since\nthe \nuracil base\n \nis only found in RNA.\n\n\n stream = BitStream(\"GAUTA\") # invalid DNA sequence\n\n\n\nThe DNA reader correctly rejects the code\n\n\n DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'\n\n\n\nbut the initial stream is partially consumed in the process:\n\n\n stream.read(str)\n'TA'\n\n\n\nThis implementation therefore only provides some basic exception safety.\nA reader that preserves the original value of the stream when an error\noccurs would provide \nstrong exception safety\n instead.\nWith snapshots, the modifications required to support this \nare plain: we simply restore the original stream whenever an\nerror occurs\n\n\n def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     snapshot = stream.save()\n...     try:\n...         bases = []\n...         for i in range(n):\n...             base = stream.read(str, 1)\n...             if base not in DNA_bases:\n...                 error = \"invalid base {0!r}\".format(base)\n...                 raise ReadError(error)\n...             else:\n...                 bases.append(base)\n...         return \"\".join(bases)\n...     except:\n...         stream.restore(snapshot)\n...         raise\n\n\n\nWith this new version, reading an invalid DNA code still \nraises an exception\n\n\n stream = BitStream(\"GAUTA\") # invalid DNA sequence\n\n DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'\n\n\n\nbut now the original stream is intact\n\n\n stream.read(str)\n'GAUTA'\n\n\n\nMultiple Snapshots\n\n\nYou can create snapshots of a stream at any stage between read/write operations.\nMultiple snapshots enable for example the implemention a hierarchy of readers \nor writers that provide strong exception safety at every level.\n\n\nHowever arbitrary sequences of save and restore are not allowed:\nwhen a given snapshot is restored, the snapshots that were created \nbetween the snapshot creation and before its restoration are forgotten.\nIn other words, saves and restores can only be applied in reverse order.\nOf course it is perfectly valid to skip some of the restores in the process:\nyou can always create additional snapshots and never use them.\n\n\nFor example, you can take two snapshots \ns0\n then \ns1\n of a stream\nbetween write operations\n\n\n stream = BitStream()\n\n s0 = stream.save()\n\n stream.write(\"A\")\n\n s1 = stream.save()\n\n stream.write(\"B\")\n\n stream == BitStream(\"AB\")\nTrue\n\n\n\nrestore \ns1\n\n\n stream.restore(s1)\n\n stream == BitStream(\"A\")\nTrue\n\n\n\nand then \ns0\n\n\n stream.restore(s0)\n\n stream == BitStream(\"\")\nTrue\n\n\n\nYou can also make the same snapshots \n\n\n stream = BitStream()\n\n s0 = stream.save()\n\n stream.write(\"A\")\n\n s1 = stream.save()\n\n stream.write(\"B\")\n\n stream == BitStream(\"AB\")\nTrue\n\n\n\nand directly restore \ns0\n\n\n stream.restore(s0)\n\n stream == BitStream(\"\")\nTrue\n\n\n\nbut then \ns1\n cannot be used anymore\n\n\n stream.restore(s1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ...\n\n\n\nHow does it Work?\n\n\nThe main (private) attributes of a \nBitStream\n structure are:\n\n\n\n\n\n\nan array of bytes: the raw data\n\n\n\n\n\n\nread and write cursors: they locate the beginning and the end \n    of the stream in the bytes array.\n\n\n\n\n\n\nWhen you read data from a stream, \nyou shift the read cursor but the \ncorresponding data is \nnot\n deleted\n1\n -- its is merely not accessible.\nThe \nState\n structure stores values \nof the read and write cursors; the call \nstate = stream.save()\n produces \na snapshot of the current cursor locations and\n\nstream.restore(state)\n restores them.\n\n\n\n\n\n\n\n\n\n\nThis is why the memory consumption increases if you write a lot\nof data into a stream, \neven if you read it!\n The solution in this case is to\ncopy the stream and discard the original since the copy method discards \nwrite history.", 
            "title": "Snapshots"
        }, 
        {
            "location": "/snapshots/#snapshots", 
            "text": "A stream is a simple model to deal with binary data,\nbut sometimes you need more: you want to perform some lookahead without \nchanging the stream or you want to try some read/write operations \nbut go back to the initial state if they fail. \nAt this stage, you probably have copies of streams \neverywhere and the stream interface seems very cumbersome.  Therefore, we provide snapshots, a simple solution for these\nuse cases that doesn't require copies of streams:\nyou can save the state of a stream at any \nstage in a sequence of read/write operations and restore \nany such state later if you need it.", 
            "title": "Snapshots"
        }, 
        {
            "location": "/snapshots/#lookahead", 
            "text": "The type of binary data can usually be identified by a specific header\ncoded in its first few bytes.\nFor example,  WAVE  audio can be detected with the function:   from bitstream import BitStream, ReadError  def is_wave(stream):\n...    try:\n...        riff = stream.read(str, 4)\n...        _ = stream.read(str, 4)\n...        wave = stream.read(str, 4)\n...        return (riff == \"RIFF\") and (wave == \"WAVE\")\n...    except ReadError:\n...        return False  The contents of an empty single-channel 44.1 kHz WAVE audio file are for example   wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'  The function  is_wave  above works as expected at first   stream = BitStream(wave)  is_wave(stream)\nTrue  but another attempt gives an incorrect answer:   is_wave(stream)\nFalse  The explanation is simple: to identify the header of a WAVE file,\nwe need to consume the first 12 bytes in the stream. \nSince this header is missing from the stream afterwards, \nthe new attempt fails.  To solve this issue, \nit's possible to make  is_wave  perform a (partial) copy of the stream \nand perform the check on the copy, leaving the initial \nstream unchanged. \nHowever in general this approach may be cumbersome;\ncopies should also be avoided when possible for performance reasons.  Bitstream also supports snapshots, \na better way to deal with lookaheads.\nWith them you can:    save the state of a stream at any time,     perform arbitrary operations on it and then     restore its initial state.    The implementation of  is_wave  that does this is plain;\nwe just make sure that whatever happens \n(even an error in the processing) \nthe original state of the stream is restored at the end.    def is_wave(stream):\n...     snapshot = stream.save()\n...     try:\n...         riff = stream.read(str, 4)\n...         _ = stream.read(str, 4)\n...         wave = stream.read(str, 4)\n...         return (riff == \"RIFF\") and (wave == \"WAVE\")\n...     except ReadError:\n...         return False\n...     finally:\n...         stream.restore(snapshot)  This version works as expected:   wave = 'RIFF$\\x00\\x00\\x00WAVEfmt \\x10\\x00\\x00\\x00\\x01\\x00\\x01\\x00D\\xac\\x00\\x00\\x88X\\x01\\x00\\x02\\x00\\x10\\x00data\\x00\\x00\\x00\\x00'  stream = BitStream(wave)  copy = stream.copy()  is_wave(stream)\nTrue  stream == copy\nTrue  is_wave(stream)\nTrue", 
            "title": "Lookahead"
        }, 
        {
            "location": "/snapshots/#exception-safety", 
            "text": "Consider the toy DNA reader below:   def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     bases = []\n...     for i in range(n):\n...         base = stream.read(str, 1)\n...         if base not in DNA_bases:\n...             error = \"invalid base {0!r}\".format(base)\n...             raise ReadError(error)\n...         else:\n...             bases.append(base)\n...     return \"\".join(bases)  It reads DNA sequences represented as strings of  'A' ,  'C' ,  'G'  and  'T'  characters:   dna = BitStream(\"GATA\")  DNA_read(dna, 4)\n'GATA'  If there is a  'U'  in the sequence, this is an error since\nthe  uracil base  \nis only found in RNA.   stream = BitStream(\"GAUTA\") # invalid DNA sequence  The DNA reader correctly rejects the code   DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'  but the initial stream is partially consumed in the process:   stream.read(str)\n'TA'  This implementation therefore only provides some basic exception safety.\nA reader that preserves the original value of the stream when an error\noccurs would provide  strong exception safety  instead.\nWith snapshots, the modifications required to support this \nare plain: we simply restore the original stream whenever an\nerror occurs   def DNA_read(stream, n=1):\n...     DNA_bases = \"ACGT\"\n...     snapshot = stream.save()\n...     try:\n...         bases = []\n...         for i in range(n):\n...             base = stream.read(str, 1)\n...             if base not in DNA_bases:\n...                 error = \"invalid base {0!r}\".format(base)\n...                 raise ReadError(error)\n...             else:\n...                 bases.append(base)\n...         return \"\".join(bases)\n...     except:\n...         stream.restore(snapshot)\n...         raise  With this new version, reading an invalid DNA code still \nraises an exception   stream = BitStream(\"GAUTA\") # invalid DNA sequence  DNA_read(stream, 4)\nTraceback (most recent call last):\n...\nReadError: invalid base 'U'  but now the original stream is intact   stream.read(str)\n'GAUTA'", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/snapshots/#multiple-snapshots", 
            "text": "You can create snapshots of a stream at any stage between read/write operations.\nMultiple snapshots enable for example the implemention a hierarchy of readers \nor writers that provide strong exception safety at every level.  However arbitrary sequences of save and restore are not allowed:\nwhen a given snapshot is restored, the snapshots that were created \nbetween the snapshot creation and before its restoration are forgotten.\nIn other words, saves and restores can only be applied in reverse order.\nOf course it is perfectly valid to skip some of the restores in the process:\nyou can always create additional snapshots and never use them.  For example, you can take two snapshots  s0  then  s1  of a stream\nbetween write operations   stream = BitStream()  s0 = stream.save()  stream.write(\"A\")  s1 = stream.save()  stream.write(\"B\")  stream == BitStream(\"AB\")\nTrue  restore  s1   stream.restore(s1)  stream == BitStream(\"A\")\nTrue  and then  s0   stream.restore(s0)  stream == BitStream(\"\")\nTrue  You can also make the same snapshots    stream = BitStream()  s0 = stream.save()  stream.write(\"A\")  s1 = stream.save()  stream.write(\"B\")  stream == BitStream(\"AB\")\nTrue  and directly restore  s0   stream.restore(s0)  stream == BitStream(\"\")\nTrue  but then  s1  cannot be used anymore   stream.restore(s1) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ...", 
            "title": "Multiple Snapshots"
        }, 
        {
            "location": "/snapshots/#how-does-it-work", 
            "text": "The main (private) attributes of a  BitStream  structure are:    an array of bytes: the raw data    read and write cursors: they locate the beginning and the end \n    of the stream in the bytes array.    When you read data from a stream, \nyou shift the read cursor but the \ncorresponding data is  not  deleted 1  -- its is merely not accessible.\nThe  State  structure stores values \nof the read and write cursors; the call  state = stream.save()  produces \na snapshot of the current cursor locations and stream.restore(state)  restores them.      This is why the memory consumption increases if you write a lot\nof data into a stream,  even if you read it!  The solution in this case is to\ncopy the stream and discard the original since the copy method discards \nwrite history.", 
            "title": "How does it Work?"
        }, 
        {
            "location": "/API/", 
            "text": "API Reference\n\n\nWe assume in the sequel that all symbols of NumPy and BitStream are available:\n\n\n from numpy import *\n\n from bitstream import *\n\n\n\nConstructor\n\n\nMost of the library features are available through the \nBitStream\n class:\n\n\nBitStream()\nCreate an empty bitstream.\nUsage\n stream = BitStream()\n\nBitStream(data, type=None)\nCreate an empty bitstream,\nthen call the \nwrite\n method.\nArguments\ndata\n is the data to be encoded.\nThe data type should be consistent with the \ntype\n argument.\ntype\n is a type identifier (such as \nbool\n, \nstr\n, \nint8\n, etc.).\ntype\n can be omitted if \ndata\n is an instance\nof a registered type or a\nlist or 1d NumPy array of such \ninstances.\nUsage\n stream = BitStream([False, True])\n\n stream = BitStream(\"Hello\", str)\n\n stream = BitStream(42, uint8)\n\nSee also\nRead / Write\nRead / Write\n\n\nBitStream.write(self, data, type=None)\nEncode \ndata\n and append it to the stream.\nArguments\ndata\n is the data to be encoded.\nIts type should be consistent with the \ntype\n argument.\ntype\n is a type identifier (such as \nbool\n, \nstr\n, \nint8\n, etc.).\ntype\n can be omitted if \ndata\n\nis an instance\nof a registered type or a\nlist or 1d NumPy array of such \ninstances.\nUsage\n stream = BitStream()\n\n stream.write(True, bool)       # explicit bool type\n\n stream.write(False)            # implicit bool type\n\n stream.write(3*[False], bool)  # list (explicit type)\n\n stream.write(3*[True])         # list (implicit type)\n\n stream.write(\"AB\", str)        # string\n\n stream.write(-128, int8)       # signed 8 bit integer\n\nSee also\nBuiltin Types\nCustom Types\nBitStream.read(self, type=None, n=None)\nDecode and consume \nn\n items of \ndata\n from the start of the stream.\nArguments\ntype\n: type identifier (such as \nbool\n, \nstr\n, \nint8\n, etc.)\nIf \ntype\n is \nNone\n a bitstream is returned.\nn\n: number of items to read\nFor most types, \nn=None\n reads one item, \nbut some types use a different convention.\nReturns\ndata\n: \nn\n items of data\nThe type of \ndata\n depends on \ntype\n and \nn\n. For built-in types:\ntype\nn = None\nn = 0, 1, 2, ...\nbool\nbool\nlist\n of bools\nBitStream\nBitStream\nBitStream\nstr\nstr\nstr\nnumpy.uint8\nnumpy.uint8\nnumpy.array\nnumpy.int8\nnumpy.int8\nnumpy.array\nnumpy.uint16\nnumpy.int16\nnumpy.array\n...\n...\n...\nfloat\nfloat\nnumpy.array\nUsage\n stream = BitStream(\"Hello World!\")\n\n stream.read(str, 2)\n'He'\n\n stream.read(bool)\nFalse\n\n stream.read(bool, 7)\n[True, True, False, True, True, False, False]\n\n stream.read(uint8, 2)\narray([108, 111], dtype=uint8)\n\n stream.read(uint8)\n32\n\n stream.read(str)\n'World!'\n\nSee also\nBuiltin Types\nCustom Types\nString Representation\n\n\nBitStream.__str__(self)\nRepresent the stream as a string of \n'0'\n and \n'1'\n.\nUsage\n print BitStream(\"ABC\")\n010000010100001001000011\n\nBitStream.__repr__(self)\nRepresent the stream as a string of \n'0'\n and \n'1'\n.\nUsage\n BitStream(\"ABC\")\n010000010100001001000011\n\nCopy\n\n\nBitstreams can be copied non-destructively with \nBitStream.copy\n. \nThey also support the interface required by the standard library \ncopy\n module.\n\n\nBitStream.copy(self, n=None)\nCopy (partially or totally) the stream.\nCopies do not consume the stream they read.\nArguments\nn\n: unsigned integer of \nNone\n.\nThe number of bits to copy from the start of the stream. \nThe full stream is copied if \nn\n is None.\nReturns\nstream\n: a bitstream.\nRaises\nReadError\n if \nn\n is larger than the length of the stream.\nUsage\n stream = BitStream(\"A\")\n\n stream\n01000001\n\n copy = stream.copy()\n\n copy\n01000001\n\n stream\n01000001\n\n stream.copy(4)\n0100\n\n stream\n01000001\n\n stream.read(BitStream, 4)\n0100\n\n stream\n0001\n\nBitStream.__copy__(self)\nBitstream shallow copy.\nUsage\n from copy import copy\n\n stream = BitStream(\"A\")\n\n stream\n01000001\n\n copy(stream)\n01000001\n\n stream\n01000001\n\nBitStream.__deepcopy__(self, memo)\nBitstream deep copy.\nUsage\n from copy import deepcopy\n\n stream = BitStream(\"A\")\n\n stream\n01000001\n\n deepcopy(stream)\n01000001\n\n stream\n01000001\n\nLength and Comparison\n\n\nBitStream.__len__(self, other)\nReturn the bitstream length in bits.\nUsage\n stream = BitStream([True, False])\n\n len(stream) \n2\n\n\n stream = BitStream(\"ABC\")\n\n len(stream)\n24\n\n len(stream) // 8\n3\n\n len(stream) % 8\n0\n\nBitStream.__eq__(self, other)\nEquality operator\nUsage\n BitStream(True) == BitStream(True)\nTrue\n\n BitStream(True) == BitStream([True])\nTrue\n\n BitStream(True) == BitStream(False)\nFalse\n\n BitStream(True) == BitStream([True, False])\nFalse\n\n\n ord(\"A\")\n65\n\n BitStream(\"A\") == BitStream(65, uint8)\nTrue\n\n BitStream(\"A\") == BitStream(66, uint8)\nFalse\n\nBitStream.__ne__(self, other)\nInequality operator\nUsage\n BitStream(True) != BitStream(True)\nFalse\n\n BitStream(True) != BitStream([True])\nFalse\n\n BitStream(True) != BitStream(False)\nTrue\n\n BitStream(True) != BitStream([True, False])\nTrue\n\n\n ord(\"A\")\n65\n\n BitStream(\"A\") != BitStream(65, uint8)\nFalse\n\n BitStream(\"A\") != BitStream(66, uint8)\nTrue\n\nBitStream.__hash__(self)\nCompute a bitstream hash \nThe computed hash is consistent with the equality operator.\nCustom Types\n\n\nUser-defined binary codecs can be bound to type identifiers.\nFor details, refer to \nCustom Types\n.\n\n\nregister(type, reader=None, writer=None)\nRegister a binary encoding (and/or) decoding.\ntype\n is a type identifier (type or \"type tag\").\nreader\n is a function with signature \nreader(stream, n=None)\n.\nwriter\n is a function with signature \nwriter(stream, data)\n.\nExceptions\n\n\nReadError\nException raised when a binary decoding is impossible.\nWriteError\nException raised when a binary encoding is impossible.\nSnapshots\n\n\nSave and restore stream states. \nFor details, refer to \nSnapshots\n.\n\n\nState\nThe \nopaque type\n of stream state.\nBitStream.save(self)\nReturn a \nState\n instance\nBitStream.restore(self, state)\nRestore a previous stream state.\nRaise a \nValueError\n if the state is invalid.", 
            "title": "API Reference"
        }, 
        {
            "location": "/API/#api-reference", 
            "text": "We assume in the sequel that all symbols of NumPy and BitStream are available:   from numpy import *  from bitstream import *", 
            "title": "API Reference"
        }, 
        {
            "location": "/API/#constructor", 
            "text": "Most of the library features are available through the  BitStream  class:  BitStream() Create an empty bitstream.", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/#read-write", 
            "text": "BitStream.write(self, data, type=None) Encode  data  and append it to the stream.", 
            "title": "Read / Write"
        }, 
        {
            "location": "/API/#string-representation", 
            "text": "BitStream.__str__(self) Represent the stream as a string of  '0'  and  '1' .", 
            "title": "String Representation"
        }, 
        {
            "location": "/API/#copy", 
            "text": "Bitstreams can be copied non-destructively with  BitStream.copy . \nThey also support the interface required by the standard library  copy  module.  BitStream.copy(self, n=None) Copy (partially or totally) the stream. Copies do not consume the stream they read.", 
            "title": "Copy"
        }, 
        {
            "location": "/API/#length-and-comparison", 
            "text": "BitStream.__len__(self, other) Return the bitstream length in bits.", 
            "title": "Length and Comparison"
        }, 
        {
            "location": "/API/#custom-types", 
            "text": "User-defined binary codecs can be bound to type identifiers.\nFor details, refer to  Custom Types .  register(type, reader=None, writer=None) Register a binary encoding (and/or) decoding. type  is a type identifier (type or \"type tag\"). reader  is a function with signature  reader(stream, n=None) . writer  is a function with signature  writer(stream, data) .", 
            "title": "Custom Types"
        }, 
        {
            "location": "/API/#exceptions", 
            "text": "ReadError Exception raised when a binary decoding is impossible. WriteError Exception raised when a binary encoding is impossible.", 
            "title": "Exceptions"
        }, 
        {
            "location": "/API/#snapshots", 
            "text": "Save and restore stream states. \nFor details, refer to  Snapshots .  State The  opaque type  of stream state. BitStream.save(self) Return a  State  instance BitStream.restore(self, state) Restore a previous stream state. Raise a  ValueError  if the state is invalid.", 
            "title": "Snapshots"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nContributors:\n \nhttps://github.com/boisgera/bitstream/graphs/contributors\n\n\nBitstream is developped on \nGitHub\n.\nTo contribute, please \nopen an issue\n or \nsubmit a pull request\n\nfor the code or documentation.\nThe following sections should help you to get started.\n\n\n\n\nGetting Started\n\n\nFirst, follow the steps required to \ninstall bitstream from sources\n.\nMake sure that you are in the project directory.\n\n\nRun the Tests\n\n\nTo run all the tests, install \npyyaml\n1\n and type\n\n\n $ python test.py\n\n\n\nIf nothing happens, your version of bitstream is probably fine: \nall the code snippets\nused \nin the documentation\n\nhave been checked by \ndoctest\n and have correct outputs.\nTo find out more about these tests, run\n\n\n $ python test.py -v\n\n\n\nThe bitstream project uses \nTravis CI\n \nto run all the tests on each new commit. \nIf you fork bitstream, make sure to \nactivate Travis CI\n.\nTo add new tests, just \nupdate the documentation\n.\n\n\nDocumentation\n\n\nThe documentation is built with \nMkDocs\n and its \n\nMaterial\n theme.\nInstall them with:\n\n\n$ pip install mkdocs mkdocs-material\n\n\n\nThe documentation sources are markdown files located \nin the \nmkdocs\n\ndirectory and assembled according to the configuration file \n\nmkdocs.yml\n.\nBuild the docs\n2\n with\n\n\n$ mkdocs build\n\n\n\nThis command outputs HTML documentation into the \ndocs\n directory.\n\n\n\n\n\n\n\n\n\n\npip install pyyaml\n\n\n\n\n\n\nFor work in progress, use \nmkdocs serve\n: it creates a web server \n  that listens on \nhttp://127.0.0.1:8000\n and refreshes automatically\n  the documentation when its source files change.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "Contributors:   https://github.com/boisgera/bitstream/graphs/contributors  Bitstream is developped on  GitHub .\nTo contribute, please  open an issue  or  submit a pull request \nfor the code or documentation.\nThe following sections should help you to get started.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#getting-started", 
            "text": "First, follow the steps required to  install bitstream from sources .\nMake sure that you are in the project directory.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/contributing/#run-the-tests", 
            "text": "To run all the tests, install  pyyaml 1  and type   $ python test.py  If nothing happens, your version of bitstream is probably fine: \nall the code snippets\nused  in the documentation \nhave been checked by  doctest  and have correct outputs.\nTo find out more about these tests, run   $ python test.py -v  The bitstream project uses  Travis CI  \nto run all the tests on each new commit. \nIf you fork bitstream, make sure to  activate Travis CI .\nTo add new tests, just  update the documentation .", 
            "title": "Run the Tests"
        }, 
        {
            "location": "/contributing/#documentation", 
            "text": "The documentation is built with  MkDocs  and its  Material  theme.\nInstall them with:  $ pip install mkdocs mkdocs-material  The documentation sources are markdown files located \nin the  mkdocs \ndirectory and assembled according to the configuration file  mkdocs.yml .\nBuild the docs 2  with  $ mkdocs build  This command outputs HTML documentation into the  docs  directory.      pip install pyyaml    For work in progress, use  mkdocs serve : it creates a web server \n  that listens on  http://127.0.0.1:8000  and refreshes automatically\n  the documentation when its source files change.", 
            "title": "Documentation"
        }
    ]
}